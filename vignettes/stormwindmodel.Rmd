---
title: "Vignette for `stormwindmodel`"
author: "G. Brooke Anderson, Seth Guikema, Joshua M. Ferreri, ..., Steven Quiring"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo = FALSE, message = FALSE}
library(stormwindmodel)
library(hurricaneexposure)
library(hurricaneexposuredata)
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(ggthemes)
```

## Overview of wind modeling process

Here is an overview of the wind modeling process implemented by this package: 

1. Impute location and maximum wind speed from hurricane track data (every 6 hours) to 15-minute intervals
2. For each storm track location, calculate all the inputs needed for the Willoughby windspeed model (forward (aka translational) speed, direction of forward motion of the storm, heading of the storm, gradient-level wind speed, radius of maximum winds, parameters for decay of winds away from the storm's center for Willoughby model). 
3. For each county center (or other grid point), estimate wind at all storm observation points. This step includes: measuring distance to county from storm center; calculating tangential wind components at county; calculating gradient wind direction at each county; determining direction at each county; calculating surface wind direction and backward wind direction.
4. Determine for each county: the maximum sustained winds and wind gust speeds at any point on the storm's track; the duration of sustained and gust winds over a certain speed (i.e., how many minutes winds were above a cutoff).

Note:

- From talking with John and Andrea, we might want to bias-correct this model based on extended tracks wind radii from 2004 on (when we have pretty complete wind radii values in the extended best tracks). Good storms to check would be Katrina, Ike, Charley, and Ivan. We should make sure to compare results from our model to extended tracks wind radii *before* adjusting by the wind gust factor, so we're comparing measures of sustained surface wind speed from both sources.

# Impute storm tracks

The storm tracks come in with observations every six hours (plus, for some, an observation at landfall). Our package has a function called `create_full_track` to linearly impute both locations (latitude and longitude) and maximum wind speed from the hurricane tracks data to a finer time resolution (default is 15 minutes, but you can also select other values using the `tint` argument). The option `tint` in this function gives the time interval you want to use, where `1` equals one hour. 

```{r}
stormwindmodel::create_full_track
```

```{r eval = FALSE}
# Old code

#Linearly intepolate to predefined time intervals (based on parameter "tint" in hours)
kk = 0
for(i in 1:nlines){
  dhr <- tdiff(yr[i+1],mon[i+1],day[i+1],hr[i+1],yr[i+1],mon[i],day[i],hr[i])
  interval = floor(dhr/tint)
  dellat = (latr[i+1]-latr[i])/interval
  dellon = (lonr[i+1]-lonr[i])/interval
  delvmx = (vmaxr[i+1]-vmaxr[i])/interval
  for(k in 1:interval){
    kk = kk + 1
    lat[kk] = latr[i] + (k-1)*dellat
    lon[kk] = lonr[i] + (k-1)*dellon
    vmax[kk] = vmaxr[i] + (k-1)*delvmx
  }
}
lat[kk+1] = latr[nlines]
lon[kk+1] = lonr[nlines]
vmax[kk+1] = vmaxr[nlines]
```

As a note, while interpolating the tracks, this function also converts the wind speed from knots (what's typically given in the hurricane tracks) to meters per second, using the following conversion:

$$
\mbox{meters per second} = 0.51444 * \mbox{knots}
$$

Also, after imputing the tracks, we're expressing longitude as a positive number, to work correctly in the models. This means that we will need to graph the negative of longitude when mapping tracks from this point of the code forward.

Here is an example of running this function like this, where `example_track` is a dataframe with the hurricane track information, and `tint` is the desired time interval to which to impute: 

```{r echo = FALSE}
data("hurr_tracks", package = "hurricaneexposuredata")
example_track <- subset(hurr_tracks, storm_id == "Floyd-1999")
```

```{r}
full_track <- create_full_track(hurr_track = example_track,
                                 tint = 0.25)
full_track[1:3, ]
```

During this imputation, the function changes the column names to `phi` for latitude, `lon` for longitude, and `sustained_Vmax` for wind speed. This is to get these names aligned with the equations we use within the Willoughby model.

Here is an example of using this function with the storm tracks from Hurricane Floyd. The figure on the left shows before imputing, and the one on the right shows after imputing:

```{r echo = FALSE, fig.width = 6}
a <- ggplot(example_track, aes(x = longitude, y = latitude)) + 
  geom_point(size = 0.3, alpha = 0.3) +
  ggtitle("Before imputing \n(every 6 hours)") + 
  theme_tufte()
b <- ggplot(full_track, aes(x = -lon, y = phi)) + 
  geom_point(size = 0.3, alpha = 0.3) + 
  ggtitle("After imputing \n(every 15 minutes)") + 
  theme_tufte()
grid.arrange(a, b, ncol = 2)
```

Questions: 

- No questions on this. I think the transfer from old code to the new function was straightforward.

Notes: 

- Based on talking with John and Andrea, it probably makes more sense for us to interpolate between 6-hourly observation points by using splines rather than doing a linear interpolation like we are here. I'm going to see what I can do to figure out how to do that appropriately.
- This is one spot where the code runs a bit slow. It might be worthwhile to come back and tweak this to run in parallel (although, not sure if that would be do-able if we change to spline interpolation) or re-code in C++.

# Adding Willoughby inputs

The next step is to process this imputed tracks and add in, for each observation point, the inputs and model parameters required for the Willoughby model. This process is done using the `add_wind_radii` function. As an input, it takes the imputed dataframe create by the `create_full_track` function. It outputs the same dataframe, but with columns added for the inputs and parameters required for the Willoughby wind model. 

For the Hurricane Floyd example: 

```{r}
with_wind_radii <- stormwindmodel::add_wind_radii(full_track = full_track)
head(with_wind_radii, 3)
tail(with_wind_radii, 3)
```

You can see that this now adds lots of measurements and parameters for each observation. Currently, there are some parameters where I've included results using the old code (e.g., `lon2km`, `lat2km`, `dx`, `dy`, `tint`, `c_x`, `c_y`, `cspeed`, `mda2`) versus newer methods of doing things, so we can see differences. Once we're happy with everything, I'll take out those older parameters to clean this function up a bit. 

The first line has some missing values, and the last line does, too. This is because you need points before and after the current point to calculate forward speed and bearing of the storm. In the old code, there were some tweaks to still get full values for the very first and very last observed points, but these required using different algorithms for those points compared to other points along the track. Since we now have points every 15 minutes, I was thinking that it is probably okay for us to miss the very first point and very last point in the track (we would have a point within 15 minutes of the dropped observation). 

Here is the full code for this function:

```{r}
stormwindmodel::add_wind_radii
```

You can see that it is mostly wrapping helper functions, which do each step of the process. I describe these helpers (and questions I have about them) below. I point out specific questions about different things in the sections for subfunctions below. 

Note: 

- Because I've made this modular, it would be pretty easy to get a CS student to go back and re-code any of the helper functions in C++ to increase speed. However, other than the function that uses the Newton-Raphson method, I would imagine that this step is not nearly as slow as the step that calculates wind speed at each grid point, so this might be lower priority for shifting to C++.

### Calculate the storm's forward speed

The first step is to determine the speed that the storm is moving forward (translational speed), in meters per second. We want to subtract this from the observed maximum wind speed to get an estimate of the maximum wind speed associated just with the rotational movement of the storm, which is what needs to go into the Willoughby model, it looks like. When we go in later and calculate wind speed for each grid point (or county center, for looking at counties), we will put this back in to get a total wind speed.

In the new code, I'm useing the Haversine method with great circle distance to calculate the distance, in kilometers, between the storm's latitude and longitude coordinates for the previous observation and the following observation. I then use the `lag` and `lead` functions from `dplyr` to get the time difference between those two points. From these, I estimate the storm's forward (translational) velocity. I convert to get this speed to meters per second (from kilometers per hour), so it's in the same units as $V_{max}$ from the imputed storm tracks.

Here is the equation I use for the Haversine method with great circle distance to calculate the distance (in kilometers) between the two locations based on their latitudes and longitudes. 

$$
hav(\theta) = hav(\phi_1 - \phi_2) + cos(\phi_1)*cos(\phi_2)*hav(L_1 - L_2)
$$
$$
D = R * \theta 
$$

where:

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $hav(\alpha)$: The haversine function, $hav(\alpha) = sin^2 \left(\frac{\alpha}{2}\right)$
- $R$: Radius of the earth, here assumed to be 6378.14 kilometers
- $D$: Distance between the two locations, in kilometers

To do this in the package, first we've got a helper function to convert between degrees and radians (`degrees_to_radians`), and then a function called `latlon_to_meters` that uses the haversine approach to calculate the distance between two latitude-longitude pairs (`phi_1` and `phi_2` are the two latitudes; `L_1` and `L_2` are the two longitudes):

```{r}
stormwindmodel:::degrees_to_radians
stormwindmodel:::latlon_to_meters
```

As a note, these are helper functions that other functions in our package use, but that users would not directly access.

We then have a function called `calc_forward_speed` that caculates the distance between two latitude-longitude pairs, calculates the time difference in their time stamps, and from that determines the forward speed in kilometers per hour and converts it to meters per second. 

```{r}
stormwindmodel:::calc_forward_speed
```

Next, there's a function called `remove_forward_speed` that uses `calc_forward_speed` to calculate the translational speed and then subtracts this from the maximum surface wind speed. If $V_{max}$ after removing the forward storm motion is ever negative, the `remove_forward_speed` function resets the value to 0 m / s.

```{r}
stormwindmodel:::remove_forward_speed
```

Questions:

1. There were originally discrepancies here between the values for forward speed generated by the old code and our code. We're pretty sure we found a bug in the old code that explains this, but let us know if we didn't get this right.
2. This I have coded differently from the original code. In the original code, this was calculated by calculating the u- and v-components of speed (forward progress per time) based on the distance traveled from the observation before the current one to the observation after the current one, measuring this distance with something that looks like it was simpler than the Haversine method for determing distance (something closer to Euclidean distance, perhaps, but determining the exact degrees-to-kilometers conversion factor for degrees longitude based on latitude). See the code below for more details. I think that the Haversine method to calculate the distance traveled using the great circle method, as I've done in the new function, would be preferable to the old code. Please let me know if you agree, or if there was some reason for doing it the way it was in the old code. I've also included a plot a bit below showing the difference between storm forward speed measured the two ways.
3. The current method of calculating distance assumes the earth has a radius of 6378.14. Are we okay with that, or do we want a different value?
4. In the current code, I'm letting the very last observation in the imputed track observations go to `NA`, since they don't have non-missing lead values (because we don't have the point after). In the old code, forward speed for these was calculated differently, but was not left as missing. How important is it to try to get some estimated value for the very last observation?

```{r eval = FALSE}
# Old code:
lon2km = 111.32*cos(rcv*(lat[i]))
lat2km = 110.54
dx = lon2km*(lon[i+1]-lon[i-1])
dy = lat2km*(lat[i+1]-lat[i-1])
c_x = (1000.*dx)/(2.0*tint*3600.)
c_y = (1000.*dy)/(2.0*tint*3600.)
cspeed = sqrt(dx*dx+dy*dy) #in original code, speed is being calculated using the 
                           #distance parameters, not velocity
#Reduce VMAX by forward speed (will be added back in after calculating wind profile)
r_vmax[i] = r_vmax[i] - cspeed
if (r_vmax[i] < 0.0){
  r_vmax[i] = 0.0
}
```

Comparing the storm's forward motion using the new (`forward_speed`) versus old (`cspeed`) methods (for the Hurricane Floyd example):

```{r warning = FALSE}
ggplot(with_wind_radii, aes(x = cspeed, y = forward_speed)) + geom_point() + 
  geom_abline(intercept = 0, slope = 1)
cor(with_wind_radii$cspeed, with_wind_radii$forward_speed, use = "complete.obs")
coef(lm(forward_speed ~ cspeed, data = with_wind_radii))
```

You can see that the two are almost perfectly correlated. However, the new way of calculating forward storm motion gives a value that's about half of the original way of calculating it.

It seems the old code uses distance, instead of velocity, to calculate `cspeed`, generating a value for forward speed nearly double what the new calculation generates. This is exemplified using the following relationships:

```{r}
1000 / (2 * .25 * 3600)
```

suggesting certain constants are missing when using the distance instead of velocity for this calculation.

Below, I have edited the old code for the `cspeed` calculation, simply changing the last line to use the calculated velocities instead of distances:

```{r eval = FALSE}
# Old code:
lon2km = 111.32*cos((pi/180)*(lat[i]))
lat2km = 110.54
dx = lon2km*(lon[i+1]-lon[i-1])
dy = lat2km*(lat[i+1]-lat[i-1])
c_x = (1000.*dx)/(2.0*tint*3600.)
c_y = (1000.*dy)/(2.0*tint*3600.)
cspeed = sqrt(c_x*c_x+c_y*c_y)
```

Now, we again compare the storm's forward motion using the new (`forward_speed`) versus old (`cspeed`)--with the final step using velocity instead of distance-- methods (for the Hurricane Floyd example):

```{r warning = FALSE}
#Create new function to create data frame with new calculation using velocity 
#for `cspeed`
add_wind_radii_2 <- function(full_track = create_full_track()){

        with_wind_radii <- dplyr::mutate(full_track,
                                  lon2km = 111.32*cos(3.14/180.0*(phi)),
                                  lat2km = 110.54,
                                  dx = lon2km*(lead(-lon)-lag(-lon)),
                                  dy = lat2km*(lead(phi)-lag(phi)),
                                  tint = 0.25,
                                  c_x = (1000*dx)/(2.0*tint*3600),
                                  c_y = (1000*dy)/(2.0*tint*3600),
                                  cspeed = sqrt(c_x*c_x+c_y*c_y),
                                  forward_speed = stormwindmodel:::calc_forward_speed(lag(phi), lag(lon),
                                                                     lag(date), lead(phi),
                                                                     lead(lon), lead(date)),
                                  mda = stormwindmodel:::calc_bearing(phi, lon,
                                                     lead(phi), lead(lon)),
                                  mda2 = stormwindmodel:::calcangle(dx, dy),
                              Vmax = stormwindmodel:::calc_gradient_speed(sustained_Vmax),
                              Vmax = stormwindmodel:::remove_forward_speed(Vmax,
                                                          lag(phi), lag(lon),
                                                          lag(date),
                                                          lead(phi), lead(lon),
                                                          lead(date)),
                              Rmax = stormwindmodel:::will7a(Vmax, phi),
                              X1 = stormwindmodel:::will10a(Vmax, phi),
                              n = stormwindmodel:::will10b(Vmax, phi),
                              A = stormwindmodel:::will10c(Vmax, phi),
                              eq3_right = stormwindmodel:::will3_right(n, A, X1, Rmax),
                              xi = mapply(stormwindmodel:::solve_for_xi, eq3_right = eq3_right),
                              R1 = stormwindmodel:::calc_R1(Rmax, xi),
                              R2 = ifelse(Rmax > 20, R1 + 25, R1 + 15)
                              )
        return(with_wind_radii)
}
#Create new data frame with corrected `cspeed` values for Floyd Example
with_wind_radii_2 <- add_wind_radii_2(full_track = full_track)
```

```{r echo = FALSE, warning = FALSE}
ggplot(with_wind_radii_2, aes(x = cspeed, y = forward_speed)) + geom_point() + 
  geom_abline(intercept = 0, slope = 1)
coef(lm(forward_speed ~ cspeed, data = with_wind_radii_2))
```

As you can see, with the changes made to the `cspeed` function, the values generated when calculating forward speed using the new `forward_speed`) versus old (`cspeed`) methods are nearly identical.

If you agree, I think we should move forward using the new code. 

### Calculate direction of storm movement ("heading")

Next, we need to calculate the direction of the motion of the storm (storm bearing). Later, we'll use this to figure out where each grid point is in relation to the angle of the storm motion. This lets us figure out whether we should add or subtract the forward motion of the storm to u- and v-components of the rotational wind speed calculated for the grid point.

I found an equation for calculating the bearing of one point from another point based on latitude and longitude. So, this is calculating the bearing of a later storm observation, as seen from an earlier storm observation. The function also restricts the output to be between 0 and 360 degrees using modular arithmetic (`%% 360`). 

$$
S = cos(\phi_{2,rad}) * sin(L_{1,rad} - L_{2,rad})
$$

$$
C = cos(\phi_{1,rad}) * sin(\phi_{2,rad}) - sin(\phi_{1,rad}) * cos(\phi_{2,rad}) * cos(L_{1,rad} - L_{2,rad})
$$

$$
\beta = atan2(S, C) * \frac{180}{\pi} + 90
$$

where: 

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $S$, $C$: Intermediary results
- $\beta$ is the direction of the storm movement, in degrees

This is implemented in our package through the `calc_bearing` function:

```{r}
stormwindmodel::calc_bearing
```

Questions: 

1. The previous code seems to have used the direction from the previous observation to the following one. I instead used the angle from the *current* observation to the next one. It seemed to me like what you really want here is the *current* bearing of the storm, or what direction it needs to move toward as of right now to get to the next observed point. Are we okay with this change? (See code below for old code).
2. Any reason to use the old method versus the new one? They give very similar results (see below)

```{r eval = FALSE}
# Old code:
lon2km = 111.32*cos(rcv*(lat[i]))
lat2km = 110.54

# calculate motion direction angle (`mda`)
# Use trig angles, so E=0, N=90, W=180, S=270)

calcangle_pair <- function(dx, dy) {
  if(is.na(dx) | is.na(dy)){
    return(NA)
  } else {
    if (dx > 0) {
      angle <- atan(dy / dx) * 180 / pi
    } else if (dx < 0) {
      angle <- 180 + atan(dy / dx) * 180 / pi
    } else {
      if (dy == 0) {
        angle <- 0
      } else{
        angle <- atan2(dy, dx) * 180 / pi
      }
    }
    if (angle < 0) {
      angle <- 360 + angle
    }
    else if (angle > 360) {
      angle <- angle - 360
    }
    return(angle)
  }
}

calcangle <- function(dx, dy){
  calcd_angle <- mapply(calcangle_pair, dx, dy)
  return(calcd_angle)
}

mda <- calcangle(dx,dy)
```

Based on the current code, these two now agree pretty well, although they're not identical (`mda` is calculated using the current code, `mda2` is calculated using the old code).

```{r echo = FALSE, warning = FALSE}
ggplot(with_wind_radii, aes(x = mda2, y = mda)) + geom_point()
coef(lm(mda ~ mda2, data = with_wind_radii))
```

Here is a plot of Floyd's track, with the motion direction angle shown by the color, to help us figure out how to interpret this angle and whether we want to make any alterations to this code: 

```{r fig.width = 5, fig.height = 3, echo = FALSE}
ggplot(with_wind_radii, aes(x = -lon, y = phi, color = mda)) + 
  geom_point() + theme_tufte() + 
    scale_colour_gradientn(colours=rainbow(4))
```

This seems to be doing okay, with an `mda` of 0 indicating the storm is moving directly east, one of 180 indicating it's moving directly west, etc. 

### Convert 1-min sustained wind at 10 m to gradient level wind speed 

The extended tracks database gives maximum winds as one minute sustained wind speeds 10 meters above the ground. To make calculations easier (by not having to deal with friction), we convert the 1-minute sustained wind speeds at 10 meters (`sustained_Vmax` in the created dataframe), which is what is given in the hurricane tracking data, to gradient level wind speed (`Vmax` in the created dataframe), using the following equation:

$$
V_{max} = \frac{V_{max,sustained}}{0.9}
$$

where:

- $V_{max}$: Mean wind speed at gradient level (m / s) 
- $V_{max,sustained}$: Surface wind speed (10 meters above the water or ground) (m / s)

This conversion seems to come from Vickery et al. 2009 (and maybe from Schwerdt et al., 1979, before that). I think they called this the "wind speed reduction factor". 

```{r}
stormwindmodel::calc_gradient_speed
```

Questions: 

- Is the 0.9 value too high? It seems like it might be on the higher end for some of the range of values given in different papers, although I'm not positive that they are all referring to the same thing. We do use this same value later to bring winds back down from gradient back to surface, so maybe it doesn't matter much as long as we're consistent?
- Should we try to use a different value for points over land? It sounded like 0.9 might be a more reasonable value over open water, but we're trying to model wind speeds over land, right? From talking with John and Andrea, it sounds like it might be appropriate to use a value about 20% lower for over-land (so, .9 * .8 = `r round(.9 * .8, 1)`). Do we want to change this? Some of the storm observations are over water, but if we needed to, we could calculate how close a storm observation is to its closest county, and it that is not very, very small, assume that the storm is over water (there are probably plenty of other ways we could do that, too, but that would be the simplest with the tools we have already in the package or easily available through other R packages). 

```{r eval = FALSE}
# Old code: 

# convert 1-min sustained wind at 10m to gradient level wind speed (for use in Holland wind profile calculation)
for(i in 1:ntime){
  r_vmax[i] = vmax[i]/0.9
}
```

Notes: 

- John and Andrea noted that, while this seemed high for any observations over land, we shouldn't change this until we're clear about how we're getting back down to surface level winds later (because it might be that we should change this the same way now when we go from surface to gradient and later when we transfer back down to surface). However, we might want a different value here depending on whether the storm is over land or over water, as long as we ensure that doesn't break anything further down the line in the code.  

### Calculate radius of maximum wind speed (Willoughby et al. 2006, Eqn 7a)

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_{max} = 46.4 e^{- 0.0155 V_{max} + 0.0169\phi}
$$

where: 

- $R_{max}$: Radius from the storm center to the point at which the maximum wind occurs (km)
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will7a
```

```{r eval = FALSE}
# Old code: 

# Calculate Radii for wind model calculations
Rmax = 46.4*exp(-0.0155*r_vmax[i]+0.0169*lat[i])   # Willoughby et al. 2006, Eqn 7a
```

Questions: 

- No questions. This part is straightforward.

Notes: 

- From talking with John and Andrea, this could be the place where we could most improve our models. There are a lot of equations for calculating the radius of maximum windspeed, and there are also estimates based on radius data from the extended tracks database (and this is probably based more on observations for the real storm). We could potentially try out different equations for this part to optimize our model if we ever want to try that in the future.

### Willoughby et al. 2006, Eqn 10a

Next, we calculate $X_1$, which is a parameter that we need for the Willoughby model. Here is the equation from the Willoughby et al. 2006 paper:

$$
X_1 = 317.1 - 2.026V_{max} + 1.915 \phi
$$

where: 

- $X_1$: Parameter for Willoughby wind model
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10a
```

```{r eval = FALSE}
# Old code: 
X1=317.1-2.026*r_vmax[i]+1.915*lat[i]				# Willoughby et al. 2006, Eqn 10a
```

Questions: 

- No questions. This part is straightforward.

### Willoughby et al. 2006, Eqn 10b

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
n = 0.4067 + 0.0144 V_{max} - 0.0038 \phi
$$

where: 

- $n$: the exponential for the power law inside the eye
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10b
```

```{r eval = FALSE}
# Old code: 
n=0.4067 + 0.0144*r_vmax[i]-0.0038*lat[i]			# Willoughby et al. 2006, Eqn 10b
```

Questions: 

- No questions. This part is straightforward.

### Willoughby et al. 2006, Eqn 10c

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
A = 0.0696 + 0.0049 V_{max} - 0.0064 \phi
$$
$$
A = \begin{cases}
0 & \text{ if } A < 0\\ 
 A & \text{ otherwise }
\end{cases}
$$

where: 

- $A$: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $V_{max}$: maximum wind (in m / s)
- $\phi$: absolute value of latitude (degrees)

```{r}
stormwindmodel::will10c
```

```{r eval = FALSE}
# Old code: 
A = 0.0696 + 0.0049*r_vmax[i]-0.0064*lat[i]  	# Willoughby et al. 2006, Eqn 10c
if(A<0){
  A=0
}
```

Questions: 

- No questions. This part is straightforward.

### Determine $R_1$ using numerical methods

Now, for the Willoughby model, we need to use a numerical method to determine the value of $R_1$ for the storm for a given observation point. To do that, we need to find the root of this equation: 

$$
w - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}} = 0
$$

where: 

- $w$: the weighting function (a function of $R_{max}$, $R_1$, and $R_2 - R_1$)
- $n$: the exponent for the power law inside the eye 
- $R_{max}$: radius at which the maximum wind occurs (km)
- $A$: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $X_1$: fitted slower exponential decay length in the outer vortex (km, I think)
- $X_2$: "the fixed rapid decay length" (Willoughby, p.1110) (km, I think). From Willoughby p.1110--1111: "We selected the most rapid decay length that seemed physically reasonable, 25 km."

The weighting function, $w$, is: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

$$
\xi = \frac{R_{max} - R_1}{R_2 - R_1}
$$

and where: 

- $w$: The weighting function
- $\xi$: A nondimensional argument
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

I wrote a function that uses the Newton-Raphson method, which seems similar to what was going on in the old code. You start with some initial guess, $x_0$, then calculate new values of $x_{n+1}$:

$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$

Until either the absolute value of $f(x_{n+1})$ is smaller than some $\epsilon$ threshold or you reach the maximum allowed number of iterations.

In this case, we're using it to try to find the value of $\xi$ that is a root for the following function: 

$$
f(\xi) = 126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}}
$$

The derivative of this function, which we need for the Newton-Raphson method, is:

$$
f'(\xi) = 5 * 126 \xi^4 - 6 * 420 \xi^5 + 7 * 540 \xi^6 - 8 * 315 \xi^7 + 9 * 70 \xi^8 
$$

```{r}
stormwindmodel::will3_right
stormwindmodel::will3_deriv_func
stormwindmodel::solve_for_xi
```

```{r eval = FALSE}
# Old code: 

f <- function(x, known){
  deriv <- 70 * 9 * x ^ 8 - 315 * 8 * x ^ 7 + 540 * 7 * x ^ 6 -
    420 * 6 * x ^ 5 + 126 * 5 * x ^ 4
  f <- 70 * x ^ 9 - 315 * x ^ 8 + 540 * x ^ 7 - 420 * x ^ 6 +
    126 * x ^ 5 - known
  temp <-c(deriv, f)
  return(temp)
}

newton2 <-function(known, eps = 10e-4, itmax = 100){

  x <- 0.5
  for(it in seq(1,itmax,by=1)){
    xo <- x
    temp2 <- f(xo,known)
    dfdx <- temp2[1]
    fx <- temp2[2]
    dx <- -fx / dfdx
    x <- xo + dx
    if(abs(dx) < eps){
      x <- 0.5
      break
    }
  }

  xin <- 0.5 + 0.1
  for(it in seq(0, itmax, by = 2)){
    xo <- x
    temp2 <- f(xo, known)
    dfdx <- temp2[1]
    fx <- temp2[2]
    dx <- -fx/dfdx
    x <- xo + dx
    if(abs(dx) < eps * abs(x)){
      break
    }
  }
  sigma <- x
  return(sigma)
}

known=n*((1-A)*X1+A*X2)/(n*((1-A)*X1+A*X2)+Rmax)	# Willoughby et al. 2006, Eqn 3 (RHS)

#sub function newton2( unfinished )
sigma = newton2(known)
if(Rmax>20){
  R1 = Rmax - 25*sigma
  R2 = R1 + 25.0
} else {
  R1 = Rmax - 15*sigma
  R2 = R1 + 15.0
}
```

Questions: 

1. It looks like the old code has more to its numerical method than the function I wrote to implement the Newton-Raphson method. Am I missing something? Should there be some more to the function I wrote?
2. It sounds like Newton-Raphson can be sensitive to the starting guess ($x_0$), so it's important to have a good starting guess. Are we sure that $x_0 = 0.5$ is good for this?
3. Should I have the function print a warning if the algorithm doesn't converge for that observation? Currently, it sets $\xi$ to be missing (`NA`) if the algorithm doesn't converge, but maybe we also need to print a message or warning every time that happens? I don't have a great idea of how often we would expect it to not converge.

### Determine R1 once you've found xi

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_1 = R_{max} - \xi(R_2 - R_1)
$$

For this function, we're assuming that $R_2 - R_1$ (the width of the transition region) is 25 kilometers when $R_{max}$ is larger than 20 kilometers and 15 kilometers otherwise.

```{r}
stormwindmodel::calc_R1
```

```{r eval = FALSE}
# Old code: 

if(Rmax>20){
  R1 = Rmax - 25*sigma
  R2 = R1 + 25.0
} else {
  R1 = Rmax - 15*sigma
  R2 = R1 + 15.0
}
```

Questions: 

- No questions. This part is straightforward.

Note: 

- From talking with John and Andrea, we want to make sure that the minimum radius estimated by the model is never lower than about 7.5 km because, if so, we could be estimating an $R_1$ that is zero or negative. If it ever gets this low, it would be during Charley or Ivan. For these, we might expect a max radius as low as 10 km (although the data estimates max radius based on wind speed, so it likely gives larger radii than were observed for small storms). 

### Determine R2 once you've found R1

Here is our equation for determining $R_2$ once we have $R_1$ and $R_{max}$:

$$
R_2 = \begin{cases}
R_1 + 25 & \text{ if } R_{max} > 20\\ 
R_1 + 15 & \text{ if } R_{max} \le 20
\end{cases}
$$

where: 

- $R_1$: Radius to the start of the transition region (km)
- $R_2$: Radius to the end of the transition region (km)

Questions:

- It seems the distance of the transition region is being set to 25 for larger storms (with $R_{max} > 20$) and to 15 for smaller storms (with $R_{max} \le 20$). I'm not sure if this is an arbitrary choice, or is there's some reference for this choice?

Here are histograms of the values we have for the radius values: 

```{r message = FALSE, warning = FALSE, fig.width = 4, fig.height = 5, echo = FALSE}
to_plot <- select(with_wind_radii, Rmax, R1, R2) %>%
  gather(key = key, value = value) %>%
  mutate(key = factor(key, levels = c("R1", "Rmax", "R2")))
ggplot(to_plot, aes(x = value)) + geom_histogram() + 
  facet_wrap(~ key, ncol = 1) + xlab("Radius (km)") + 
  theme_tufte()
```

Here are histograms for some of the other Willoughby parameters we get for Floyd:

```{r message = FALSE, warning = FALSE, fig.width = 5, fig.height = 4, echo = FALSE}
to_plot <- select(with_wind_radii, Vmax, Rmax, X1, n, A, xi) %>%
  gather(key, value)
ggplot(to_plot, aes(x = value)) + geom_histogram() + 
  facet_wrap(~ key, ncol = 2, scales = "free") + 
  theme_tufte()
```

We can check these against the Willoughby paper to make sure that we're getting reasonable values for all of the parameters.

# Calculate wind speed at each grid point 

Next, we calculate wind characteristics at each grid point (or county center location) for every storm observation. These characteristics are: 

- `max_gust`: Maximum value of surface-level (10 meters) sustained winds, in meters per second, over the length of the storm at the given location
- `max_sust`: Maximum value of surface-level (10 meters) gust winds, in meters per second, over the length of the storm at the given location
- `gust_duration`: Length of time, in minutes, that surface-level sustained winds were above a certain wind speed cutoff (e.g., 20 meters per second)
- `sust_duration`: Length of time, in minutes, that surface-level gust winds were above a certain wind speed cutoff (e.g., 20 meters per second)

I've created the following function to calculate these characteristics at a location (note: this function calculates wind characteristics at a single location; I have a later function that applies this to all of our grid points):

```{r}
stormwindmodel::calc_grid_wind
```

Again, I've written this function so it uses a lot of smaller "helper" functions for each step. I have specific questions about some of those below. As an input, this function requires both the output dataframe from `add_wind_radii` (which gives all of the parameters for the Willoughby model at each point on the storm's track) and also a location (latitude and longitude) where you want to model winds. To work well with later functions, this location information should be input as a one-row dataframe rather than a vector. That `grid_point` input might look something like this:

```{r echo = FALSE}
data(county_points)
county_points[1, ]
```

(As a note, I've included in the package a dataset called `county_points` that has the population mean centers of each county in the states mapped in the later maps, so this dataset can be used directly from the package to determine county-level exposures.)

The column names for latitude and longitude must be `glat` and `glon`, both should be in decimal degrees, and the longitude should be expressed using negative numbers for the Western hemisphere (so, almost all of the points we'll have for Atlantic basin storms).

Here is an example of running that functions, and the output you get (notice that it only outputs a one-row matrix, because it only works with one location at a time):

```{r}
calc_grid_wind(grid_point = county_points[1, ],
               with_wind_radii = with_wind_radii)
```

If you want, you can change the cutoffs you're using for the duration measurements (in this example, I'm using a very low value of 5 m / s just so the example will pick up something-- this location was pretty far from the storm track, I think): 

```{r}
calc_grid_wind(grid_point = county_points[1, ],
               with_wind_radii = with_wind_radii,
               gust_duration_cut = 5, 
               sust_duration_cut = 5)
```

### Get r for the grid point

The first step is to determine the distance between the grid point and the center of the storm ($r$). As with the previous main function, here I am using the haversine method of great circle distance to calculate this distance. For this, I use the `latlon_to_meters` function given in the code shown above.

Here is the relationship between $r$ determined using the old (`r2`) and the new (`r`) methods (the blue points show the values for $r$ and $r2$, while the black line is a reference with zero intercept and slope of 1): 

```{r echo = FALSE}
 grid_wind <- mutate(with_wind_radii,
                            lon2km = 111.32 * cos(pi * phi / 180),
                      dx = lon2km * (-lon - grid_point$glon),
                      dy = 110.54 * (grid_point$glat - phi),
                      r2 = sqrt(dx^2 + dy^2),
                      r = latlon_to_meters(phi, -lon,
                                            grid_point$glat,
                                            grid_point$glon))
ggplot(grid_wind, aes(x = r2, y = r)) + 
  geom_point(alpha = 0.2, size = 0.2, color = "blue") + 
  geom_abline(intercept = 0, slope = 1) + 
  theme_tufte()
```

To me, it looks like the two sets of code are pretty similar on this, certainly for points close to the storm track. 

Here are the distances between the storm center and the example grid point across all of the storm track observations. 

```{r fig.width = 5, fig.height = 3, echo = FALSE}
ggplot(grid_wind, aes(x = -lon, y = phi, color = r)) + geom_point() + 
  geom_point(data = grid_point, aes(x = glon, y = glat), color = "red") + 
  theme_tufte() + 
    scale_colour_gradientn(colours=rainbow(4))
```

Questions: 

- The two methods for determining distance to the grid point (something that looks like Euclidean distance and the haversine method) seem to give pretty similar answers. I think the second method appeals more to me. Any votes otherwise, to keep the old way of determining this?

### Determine gradient wind speed (tangential wind) at each location

Next, the package calculates $V(r)$, the tangential wind component at radius $r$. Note there are different equations for this for (1) the eye to the start of the transition region; (2) outside the transition region; and (3) within the transition region.

First, if $r \le R_1$, you are supposed to use this equation to calculate $V(r)$ (Willoughby et al. 2006, Eqn 1 (a)):

$$
V(r) = V_i = V_{max} \left( \frac{r}{R_{max}} \right)^n, (0 \le r \le R_1)
$$

Next, if $r \ge R_2$, you are suppose to use this equation to calculate $V(r)$ using this equation (Willoughby et al. 2006, Eqn 4; dual-exponential replacement of Eqn 1 (b)):

$$
V(r) = V_o = V_{max}\left[(1 - A) e^\frac{R_{max} - r}{X_1} + A e^\frac{R_{max} - r}{X_2}\right], R_2 < r
$$

Finally, if $r$ for the grid point is between $R_1$ and $R_2$, we need to calculate $\xi$ using the value we calculated for $r$ for the grid point: 

$$
\xi = \frac{r - R_1}{R_2 - R_1}
$$

and then: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

- $w$: Weighting variable
- $\xi$: A nondimensional argument
- $r$: radius from the storm center to the grid point (in km)
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

Willoughby et al. 2006, Eqn 1 (c):

$$
V(r) = V_i (1 - w) + V_o w, (R_1 \le r \le R_2)
$$

All of this is wrapped in the `will1` function (named after the equation in Willoughby et al.):

```{r}
stormwindmodel:::will1
```

```{r eval = FALSE}
# Old code

# Begin Holland2 model to calculate gradient windspeed distribution
    # *Note:  Wind speed scaled by 100 - must undo after calculation
    if(r < R1){
      track[j]=r_vmax[i]*(r/Rmax)^n*100
    } else if (r > R2){
      track[j]=r_vmax[i]*((1-A)*exp((Rmax-r)/X1)+A*exp((Rmax-r)/X2))*100
    } else if(r > R1 && r < R2){
      eps=(r-R1)/25
      w=126*eps^5-420*eps^6+540*eps^7-315*eps^8+70*eps^9
      v_temp1=r_vmax[i]*(r/Rmax)^n
      v_temp2=r_vmax[i]*((1-A)*exp((Rmax-r)/X1)+A*exp((Rmax-r)/X2))
      track[j]=(v_temp1*(1-w)+v_temp2*w)*100
    }
    track[j] = track[j]/100.0
    if (track[j] < 0.0){
      track[j] = 0.0
    }
```

Questions: 

- I don't think I have any questions about this part.

Here are some values from doing this process on the example grid point from the North Carolina county (on the Outer Banks, I believe) for Floyd (`track` is the gradient rotational wind speed, in meters per second):

```{r echo = FALSE, warning = FALSE, message = FALSE, fig.width = 8, fig.height = 2.5}
grid_wind <- mutate(with_wind_radii,
                            lon2km = 111.32 * cos(pi * phi / 180),
                      dx = lon2km * (-lon - grid_point$glon),
                      dy = 110.54 * (grid_point$glat - phi),
                      r2 = sqrt(dx^2 + dy^2),
                      r = latlon_to_meters(phi, -lon,
                                            grid_point$glat,
                                            grid_point$glon),
                      track = mapply(stormwindmodel:::will1, r = r, Rmax = Rmax,
                                     R1 = R1, R2 = R2,
                                     Vmax = Vmax, n = n, A = A, X1 = X1))
a <- ggplot(grid_wind, aes(x = track)) + geom_histogram()
b <- ggplot(grid_wind, aes(x = -lon, y = phi, color = track)) + geom_point() + 
  geom_point(data = grid_point, aes(x = glon, y = glat), color = "red")
grid.arrange(a, b, ncol = 2)
```

To me, this seems to be doing okay. It would probably be worthwhile to compare with any reported values of rotational wind speeds at the Outer Banks during this storm to verify that these values are in the right neighborhood.

### Calculate the angle between the storm center and each grid point

So far, the model has just calculated the the wind storm component of the wind speed at each grid location. Now it needs to add back in the forward motion component of the wind speed at each location. This requires, for each grid point, adding the separate vectors of forward wind speed and storm wind speed [maybe there's a better word for this?]. When these vectors point in the same direction, the total storm winds will be increased by the forward motion (the right side of the storm). Conversely, on the left side of the storm, the forward motion of the storm will offset some of the storm-related wind. 

To get the total wind speed at a grid point, we need to add these two wind speed vectors together and then take the magnitude of the resulting vector. The wind speed from the forward motion of the storm will have the same angle and magnitude at every grid point. [I think that this is generally what's going on from this point forward-- correct me if I'm wrong.]

We've already determined the direction of the forward direction of the storm. So, to add the two wind components together, we need to get the direction of the storm winds at the grid point using the same coordinate system. 

```{r}
stormwindmodel:::calc_bearing
```

```{r eval = FALSE}
# Old code

dx = lon2km*(lon[i]-glon[j])
    dy = lat2km*(glat[j]-lat[i]) #changed k to j
    r = sqrt(dx*dx+dy*dy)
    # calculate the gradient wind direction (gwd) at this grid point
    gwd <- calcangle(dx, dy)
    gwd = gwd - 90.0

    if (gwd < 0.0){
      gwd = 360.0 + gwd
    } else if (gwd > 360.0){
      gwd = gwd - 360.0
    }
    
calcangle_pair <- function(dx, dy) {
  if(is.na(dx) | is.na(dy)){
    return(NA)
  } else {
    if (dx > 0) {
      angle <- atan(dy / dx) * 180 / pi
    } else if (dx < 0) {
      angle <- 180 + atan(dy / dx) * 180 / pi
    } else {
      if (dy == 0) {
        angle <- 0
      } else{
        angle <- atan2(dy, dx) * 180 / pi
      }
    }
    if (angle < 0) {
      angle <- 360 + angle
    }
    else if (angle > 360) {
      angle <- angle - 360
    }
    return(angle)
  }
}

calc_bearing <- function(phi_1, L_1, phi_2, L_2){
  phi_1 <- degrees_to_radians(phi_1)
  L_1 <- degrees_to_radians(L_1)
  phi_2 <- degrees_to_radians(phi_2)
  L_2 <- degrees_to_radians(L_2)

  S <- cos(phi_2) * sin(L_1 - L_2)
  C <- cos(phi_1) * sin(phi_2) - sin(phi_1) * cos(phi_2) * cos(L_1 - L_2)

  beta_rad <- atan2(S, C)
  beta <- radians_to_degrees(beta_rad) + 90
  return(beta)
}
```

Here is a plot of the gradient wind direction calculated the old (`gwd2`) and new `gwd` ways:

```{r echo = FALSE}
grid_wind <- mutate(with_wind_radii,
                      lon2km = 111.32 * cos(pi * phi / 180),
                      dx = lon2km * (-lon - grid_point$glon),
                      dy = 110.54 * (grid_point$glat - phi),
                      # calculate the gradient wind direction (gwd) at this
                      # grid point
                      bearing_from_storm = (180 - (stormwindmodel:::calc_bearing(phi, -lon,
                                                              grid_point$glat,
                                                              grid_point$glon))),
                      gwd2 = (180 - stormwindmodel:::calcangle(dx, dy))  %% 360,
                      gwd = (bearing_from_storm) %% 360)
ggplot(grid_wind, aes(x = gwd2, y = gwd)) + geom_point() 
coef(lm(gwd ~ gwd2, data = grid_wind))
```

The old and new methods seem to agree very well. Here are the gradient wind directions for this sample county over time, so we can check if the gradient wind direction values are reasonable. 

```{r echo = FALSE, fig.width = 5, fig.height = 3}
ggplot(grid_wind, aes(x = -lon, y = phi, color = gwd)) + geom_point() + 
  geom_point(data = grid_point, aes(x = glon, y = glat), color = "red")
```
 
The direction seems to change pretty quickly when the storm passes. I think that could also be a good sign that this model is working reasonably well. 

### Calculate the surface wind direction

I think that this next step is to change from the gradient wind direction to the surface wind direction by adding 20 degrees to the gradient wind direction (and then making sure the final answer is between 0 and 360 degrees). It sounds like this is necessary because surface friction changes the wind direction a bit near the surface compared to higher (is this right? is this why we need this extra 20 degrees at the surface?).

$$
swd = gwd + 20
$$

Questions: 

- Am I right? Is that what's going on with this step?
- In terms of terminology, is it appropriate to refer to this 20 degrees as the "inflow angle" or the "inflow angle correction"?
- Do we want to do something more complex with this than always adding 20 degrees? I found an equation based on the relationship between the distance from the storm center and the storm's $R_{max}$ at that observation point (Phadke et al., 2003). Do we want to use that instead?

Notes: 

- From talking with John and Andrea, first we probably want to use 40 for the inflow angle, rather than 20, since all our grid points (or county centers) are over land, and 40 is a better inflow angles over land.
- Also, we probably want to put this behind the part where we bring gradient values back down to surface estimates.

Phadke et al., 2003, equation: 

$$
\beta = \begin{cases}
 & 10 + \left(1 + \frac{R}{R_{max}}\right) \text{ if } R < R_{max}\\ 
 & 20 + 25\left(\frac{R}{R_{max}} - 1 \right ) \text{ if } R_{max} \le R \le 1.2R_{max}\\ 
 & 25 \text{ if } R \ge 1.2R_{max}
\end{cases}
$$

```{r eval = FALSE}
# New code
swd = (gwd + 20) %% 360

# Old code
swd = gwd + 20
    mult = 0.9
    if (swd < 0.0){
      swd = 360.0 + swd
    } else if (swd > 360.0){
      swd = swd - 360.0
    }
```


### Calculate the u and v components of surface wind

Now the model must add together the two vectors of wind speeds for the grid point, the vector of forward storm motion $\left(\vec{F}\right)$ and the vector of the storm wind $\left(\vec{S}\right)$. To add the two vectors together, we need to break them each into north-south component $\left(v(\vec{F})\right)$ and east-west component $\left(v(\vec{F})\right)$, where a positive value of $v$ indicates northward motion (or wind from the south) and a positive value of $u$ indicates eastward motion (or wind from the west).

From an NCAR reference website (wind direction quick reference):

$$
u(\vec{F}) = -\left \| \vec{F} \right \| sin\left(\theta_F \frac{\pi}{180}\right)
$$

$$
v(\vec{F}) = -\left \| \vec{F} \right \| cos\left(\theta_F \frac{\pi}{180}\right)
$$

Then, you should be able to get the u- and v-components of the total wind speed, $\left(\vec{T}\right)$, by adding the two u-components for the two wind speeds and the two v-components for the two wind speeds:

$$
u\left(\vec{T}\right) = u\left(\vec{F}\right) + u\left(\vec{S}\right)
$$

$$
v\left(\vec{T}\right) = v\left(\vec{F}\right) + v\left(\vec{S}\right)
$$

Once you have the u- and v-components, you can calculate the total wind speed (which is the magnitude of this vector):

$$
\left \| \vec{T} \right \| = \sqrt{u\left(\vec{T}\right)^2 + v\left(\vec{T}\right)^2}
$$

Here is the equation of what we're doing in the code at this step:

$$
u_{wind} = 0.9*track*cos(\frac{swd \pi}{180}) 
$$
$$
v_{wind} = 0.9*track*sin(\frac{swd \pi}{180}) 
$$

where `track` is the surface rotational wind speed of the storm at the grid point for the given observation time and `swd` is the surface wind direction.

```{r eval = FALSE}
# New code
uwind = 0.9 * cos(swd * pi / 180) * track,
vwind = 0.9 * sin(swd * pi / 180) * track,

# Old code
mult = 0.9
rcv = 3.14/180.0
uwind[i,j] = mult*cos(rcv*swd)*track[j]
vwind[i,j] = mult*sin(rcv*swd)*track[j]
```

Questions: 

- Why are we multiplying by 0.9? Is this to convert back to sustained wind speed from gradient wind speed? Or is this the onshore-to-overland wind ratio? It seems about right for that (see the table of wind ratios below).

Notes:

- From John and Andrea: This looks like it's just reversing what we did before, when we went from surface to gradient, so we could remove friction when calculating our estimates. However, it looks like we did not do any adjustment for the added friction over land. It sounds like at this point we probably want to do some adjustment for wind speed that accounts for all the grid points being land-based ones. 

Onshore-to-overwater wind ratios (from NOAA 23, p. 31, for 10-meter, 10-minute wind speed): 

location | wind ratio
---------|-----------
water to land | 0.89
water to awash | 0.95
water to rough terrain | 0.83

Note: 

- After meeting with John and Andrea, I'm pretty sure we're not making any of the corrections in this table. 

### Calculate total wind speed

Next, we want to combine the translational and rotational components of wind speed at the grid point to get a total wind speed. 

The code first has us calculating a wind speed, but it seems like we're just adding back together the u- and v-components of just the rotational wind speed, just after taking 0.9 of each? Why did we break these apart in the last step if we're putting them back together immediately?

$$
windspd = \sqrt{u_{wind}^2 + v_{wind}^2}
$$

```{r eval = FALSE}
# New code
windspd = sqrt(uwind^2 + vwind^2)

# Old code
windspd[i,j] = sqrt((uwind[i,j])^2+(vwind[i,j])^2)
```

Next, to add back in the storm's forward motion at each grid point, it looks like we are adding, to any non-negative rotational wind speed, the forward wind speed of the storm's center, adjusted for direction of the grid point from the center using a cosine of the angle difference between the angle of the surface wind (`swd`) and the angle of storm forward movement (`mda`) plus a constant to adjust for the fact that our wind speeds are in meters per second rather than knots:

$$
\beta = swd - mda
$$
$$
A = 1.5\left(T^{0.63}\right)\left(0.514791^{0.37}\right)cos(\beta)
$$
$$
windspd = \begin{cases}
windspd + 1.5 * A  & \text{ if } windspd \ge 0\\ 
0 & \text{ if } windspd < 0
\end{cases}
$$

The $A$ calculated here is referred to in the NOAA 23 report as an "asymmetry factor" for maximum, 10-meter, 10 minute overwater windspeed. 

From the NOAA 23 report: 

> "A is added to the winds on the right of a storm track and subtracted from those on the left."

The same report describes $\beta$ as "the angle between the track direction ($\theta$) and the surface wind direction."

Questions: 

- I think that there's a bug in the old code here. It looks like someone put in exponential operations some places that should have been multiplications. This would probably have been an easy mistake to make in transferring the code from Fortran. The new version of calculating $A$ is the correct one, right?

```{r}
stormwindmodel:::add_storm_motion_wind
```

```{r eval = FALSE}
# Old code
# Add back in wind component due to storm motion (only where windspd > 0 m/s)
# From NOAA Technical Report 23, Schwerdt et al., pg. 25
if (windspd[i,j] > 0.0){
  beta = swd-mda
  windspd[i,j] = windspd[i,j]+1.5*((cspeed)^0.63)^((0.514751)^0.37)*cos(rcv*beta)
  if (windspd[i,j] < 0.0){
    windspd[i,j] = 0.0
  }
}
```


### Convert 1-min winds at 10-m to 3-sec gust at surface

The last step in the code does this:

$$
windspd = 1.3*windspd 
$$

I think the 1.3 is some kind of gust factor. Is that right? In one of the sources I was looking at, there's this table for this gust factor: 

Location | Gust factor
---------|-------------
in-land | 1.49
just offshore | 1.36
just onshore | 1.23
at sea | 1.11

```{r eval = FALSE}
# New code
windspd = windspd * 1.3

# Old code
# Convert 1-min winds at 10-m to 3-sec gust at surface
windspd[i,j] = windspd[i,j]*(1.3)
```

Note: 

- Based on talking with John and Andrea, we probably want to check the output up to this point against the hurricane tracks data. After this point, we are converting to gusts, not sustained winds (what the extended hurricane tracks give).
- Also based on that conversation, we probably want to update the 1.3. It sounds like this gust factor is likely larger over land.

## Putting everything together

There's a wrapper function called `get_grid_winds` that puts everything together. As inputs, it takes the storm tracks and the grid point locations. It outputs a dataframe like this: 

```{r cache = TRUE}
grid_winds_katrina <- get_grid_winds(hurr_track = subset(hurr_tracks,
                                                  storm_id == "Katrina-2005"),
                                     grid_df = county_points)
```

with the maxmium sustained and gust wind speeds (in meters per second) and duration of winds over 20 meters per second for each wind type (this cutoff point can be customized with the `gust_duration` and `sust_duration` arguments) added for each grid point.

I also have a function to map county-level estimates. Here's an example of calculating and mapping county winds for Katrina:

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
map_wind(grid_winds_katrina, value = "max_gust")
map_wind(grid_winds_katrina, value = "max_sust")

map_wind(grid_winds_katrina, value = "max_gust", break_point = 20)
```

I am also saving a file of the county winds from Katrina, that we can use to validate against the earlier Fortran code if we want.

```{r}
write.csv(grid_winds_katrina, file = "../writing/katrina_county_winds.csv")
write.csv(tracts, file = "../writing/county_points.csv")
```

### Additional questions

I had some more questions about the model: 

1. Does it ever account for being over land versus water? It looks like some models have two components for this: first, the storm itself weakens once the main part is over land and second the wind speed is lower over land for the same strength of storm because of the added friction. As far as I can tell, this doesn't seem to be part of the model yet? (It looks like "filling rate models" are sometimes used by others to model hurricane decay after landfall?)
2. The old code comments mention the Holland model some, but it looks like the actual code now justs uses the Willoughby model. Is that right? Are those comments just left over, as the code was evolving?
