---
title: "Vignette for `stormwindmodel`"
author: "G. Brooke Anderson, Andrea Schumacher, Seth Guikema, Joshua M. Ferreri, ..., Steven Quiring"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo = FALSE, message = FALSE}
library(stormwindmodel)
library(hurricaneexposure)
library(hurricaneexposuredata)
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(ggthemes)
```

## Overview of wind modeling process

Here is an overview of the wind modeling process implemented by this package: 

1. Impute location and maximum wind speed from hurricane track data (every 6 hours) to 15-minute intervals
2. For each storm track location, calculate all the inputs needed for the Willoughby wind speed model (forward speed, direction of forward motion of the storm, gradient-level wind speed, radius of maximum winds, parameters for decay of winds away from the storm's center for Willoughby model). 
3. For each county center (or other grid point), estimate surface-level sustained wind and 3-second wind gusts at all storm observation points (i.e., all points along the interpolated storm track). This step includes: measuring distance to county from storm center (radius); calculating tangential gradient wind components at that grid point; calculating gradient wind direction at that grid point; calculating surface wind speed; calculating surface wind direction, adding storm forward motion back into surface wind estimate.
4. Determine for each county: the maximum sustained winds and wind gust speeds at any point on the storm's track; the duration of sustained and gust winds over a certain speed (i.e., how many minutes winds were above a cutoff).

# Impute storm tracks

The storm tracks come in with observations every six hours (plus, for some, an observation at landfall). Our package has a function called `create_full_track` that imputes both locations (latitude and longitude) and intensity (maximum wind speed) from the hurricane tracks data to a finer time resolution (default is 15 minutes, but you can also select other values using the `tint` argument). This imputation uses a natural cubic spline, with the degrees of freedom set as the number of timed observations for the storm in the input data (typically best tracks data) divided by two. The option `tint` in this function gives the time interval you want to use, where `1` equals one hour. 

```{r}
stormwindmodel::create_full_track
```

Here is an example of running this function like this, where `example_track` is a dataframe with the hurricane track information, and `tint` is the desired time interval to which to impute: 

```{r echo = FALSE}
data("hurr_tracks", package = "hurricaneexposuredata")
example_track <- subset(hurr_tracks, storm_id == "Floyd-1999")
```

```{r}
full_track <- create_full_track(hurr_track = example_track,
                                 tint = 0.25)
full_track[1:3, ]
```

# Adding Willoughby inputs

The next step is to process this imputed track and add in, for each observation point, the inputs and model parameters required for the Willoughby model. This process is done using the `add_wind_radii` function. As an input, it takes the imputed dataframe create by the `create_full_track` function. It outputs the same dataframe, but with columns added for the inputs and parameters required for the Willoughby wind model. 

For the Hurricane Floyd example: 

```{r}
with_wind_radii <- stormwindmodel::add_wind_radii(full_track = full_track)
head(with_wind_radii, 3)
tail(with_wind_radii, 3)
```

This adds lots of measurements and parameters for each observation. The first line has some missing values, and the last line does, too. This is because you need points before and after the current point to calculate forward speed and bearing of the storm. 

Here is the full code for this function:

```{r}
stormwindmodel::add_wind_radii
```

You can see that this function is mostly wrapping helper functions, which do each step of the process. I describe these helpers (and questions I have about them) below. 

Note: 

- Because I've made this modular, it would be pretty easy to get a student to go back and re-code any of the helper functions in C++ to increase speed. However, other than the function that uses the Newton-Raphson method, I would imagine that this step is not nearly as slow as the step that calculates wind speed at each grid point, so this might be lower priority for shifting to C++.

### Calculate the storm's forward speed

The first step is to determine the speed that the storm is moving forward (translational speed), in meters per second. We want to subtract this from the observed maximum wind speed to get an estimate of the maximum wind speed associated just with the rotational movement of the storm, which is what needs to go into the Willoughby model. When we go in later and calculate wind speed for each grid point (or county center, for looking at counties), we will put this back in to get a total wind speed.

In the new code, I'm using the Haversine method with great circle distance to calculate the distance, in kilometers, between the storm's latitude and longitude coordinates for the previous observation and the following observation. I then use the `lag` and `lead` functions from `dplyr` to get the time difference between those two points. From these, I estimate the storm's forward (translational) velocity. I convert to get this speed to meters per second (from kilometers per hour), so it's in the same units as $V_{max}$ from the imputed storm tracks.

Here is the equation I use for the Haversine method with great circle distance to calculate the distance (in kilometers) between the two locations based on their latitudes and longitudes. 

$$
hav(\theta) = hav(\phi_1 - \phi_2) + cos(\phi_1)*cos(\phi_2)*hav(L_1 - L_2)
$$
$$
D = R * \theta 
$$

where:

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $hav(\alpha)$: The haversine function, $hav(\alpha) = sin^2 \left(\frac{\alpha}{2}\right)$
- $R$: Radius of the earth, here assumed to be 6378.14 kilometers
- $D$: Distance between the two locations, in kilometers

To do this in the package, first we've got a helper function to convert between degrees and radians (`degrees_to_radians`), and then a function called `latlon_to_km` that uses the haversine approach to calculate the distance between two latitude-longitude pairs (`phi_1` and `phi_2` are the two latitudes; `L_1` and `L_2` are the two longitudes):

```{r}
stormwindmodel:::degrees_to_radians
stormwindmodel:::latlon_to_km
```

We then have a function called `calc_forward_speed` that caculates the distance between two latitude-longitude pairs, calculates the time difference in their time stamps, and from that determines the forward speed in kilometers per hour and converts it to meters per second. 

```{r}
stormwindmodel:::calc_forward_speed
```

Notes:

- This I have coded differently from the original code. In the original code, this was calculated by calculating the u- and v-components of speed (forward progress per time) based on the distance traveled from the observation before the current one to the observation after the current one, measuring this distance with something that looks like it was simpler than the Haversine method for determing distance (something closer to Euclidean distance, perhaps, but determining the exact degrees-to-kilometers conversion factor for degrees longitude based on latitude). I think that the Haversine method to calculate the distance traveled using the great circle method, as I've done in the new function, would be preferable to the old code, although  in talking with Andrea, we don't think it should make much difference in final estimates whether we do this or a simpler method of calculating distance. This is one spot where we might want to check profiling and simplify the method if this step takes a while to run.
- The current method of calculating distance assumes the earth has a radius of 6378.14. 

### Calculate direction of storm movement ("heading")

Next, we need to calculate the direction of the motion of the storm (storm bearing). Later, we'll use this to add back in a component for the forward motion of the storm into the wind estimates. 

I found an equation for calculating the bearing of one point from another point based on latitude and longitude. So, this is calculating the bearing of a later storm observation, as seen from an earlier storm observation. The function also restricts the output to be between 0 and 360 degrees using modular arithmetic (`%% 360`). 

$$
S = cos(\phi_{2,rad}) * sin(L_{1,rad} - L_{2,rad})
$$

$$
C = cos(\phi_{1,rad}) * sin(\phi_{2,rad}) - sin(\phi_{1,rad}) * cos(\phi_{2,rad}) * cos(L_{1,rad} - L_{2,rad})
$$

$$
\beta = atan2(S, C) * \frac{180}{\pi} + 90
$$

where: 

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $S$, $C$: Intermediary results
- $\beta$ is the direction of the storm movement, in degrees

This is implemented in our package through the `calc_bearing` function:

```{r}
stormwindmodel::calc_bearing
```

Notes: 

- Again, I'm using a bit of a more complex method here than in the old code. Based on talking with Andrea, we could simplify this method if it's computationally expensive. 
- The old code used the direction from the previous observation to the following one. I instead used the angle from the *current* observation to the next one. It seemed to me like what you really want here is the *current* bearing of the storm, or what direction it needs to move toward as of right now to get to the next observed point. This new code reflects this.

### Calculate u- and v-components of forward speed

Next, we use the estimated magnitude and direction of the storm's forward speed to calculate u- and v-components of this forward speed. Later, we will add back in these two components, after adjusting for the Phadke correction factor for forward motion.

To calculate the u- and v-components of forward motion, $V_{F,u}$ and $V_{F,v}$, we used: 

$$
V_{F,u} = \left|\overrightarrow{V_{F}}\right| cos(\theta)
$$

$$
V_{F,v} = \left|\overrightarrow{V_{F}}\right| sin(\theta)
$$

where $\theta$ is the direction of the storm movement (0 for due east, 90 for due north, etc.).

### Adjust wind speed to remove forward motion of storm

Next, there's a function called `remove_forward_speed` that uses the estimated forward speed in equation 12 (and accompanying text) from Phadke et al. 2003 to adjust wind speed to remove the component from forward motion. 

Because here we are trying to adjust the maximum sustained wind to remove the component from forward speed, we can assume that we are adjusting wind speed at the radius of maximum winds and for winds blowing in the same direction as the direction of the forward motion of the storm. Therefore, the correction term for forward motion is $U = 0.5 * V_F$ (Phadke et al. 2003), or half the total forward speed of the storm. We substract this correction factor from the maximum sustained wind speed to remove the forward component, and because we assume that the maximum winds are blowing in the same direction as the direction of the storm's forward motion, we can directly subtract this correction term from the magnitude of the wind speed (rather than needing to break into u- and v-components for a vector addition).

If $V_{max}$ after removing the forward storm motion is ever negative, the `remove_forward_speed` function resets the value to 0 m / s.

```{r}
stormwindmodel:::remove_forward_speed
```

### Convert 1-min sustained wind at 10 m to gradient level wind speed 

The extended tracks database gives maximum winds as one minute sustained wind speeds 10 meters above the ground. To make calculations easier (by not having to deal with friction), we convert the 1-minute sustained wind speeds at 10 meters (`sustained_Vmax` in the created dataframe), which is what is given in the hurricane tracking data, to gradient level wind speed (`Vmax` in the created dataframe), using the following equation:

$$
V_{max} = \frac{V_{max,sustained}}{rf}
$$

where:

- $V_{max}$: Mean wind speed at gradient level (m / s) 
- $V_{max,sustained}$: Surface wind speed (10 meters above the water or ground) (m / s)
- $rf$: Reduction factor for $r \le$ 100 km.

The reduction factor come from Knaff et al., 2003, Figure 3. We assume that $R_{max}$ is always 100 km or less. Then, $rf$ is 0.9 if the storm's center is over water and 80% of that, 0.72, if the storm's center is over land.  

```{r}
stormwindmodel::calc_gradient_speed
```

To determine if the storm center is over land or over water, we calculate its distance to all the county centers (eastern half of the United States). If the storm is within 30 km of at least one county center, we designate the storm center as "over land", and "over water" otherwise: 

```{r}
stormwindmodel:::check_over_land
```

```{r warning = FALSE, fig.width = 8, fig.height = 6, message = FALSE}
over_land <- mapply(stormwindmodel:::check_over_land,
                    phi = full_track$phi,
                    lon = full_track$lon)
to_plot <- full_track %>%
  mutate(over_land = over_land)
us <- ggmap::get_map("North Caroline", zoom = 4)
ggmap::ggmap(us) + 
  geom_point(data = to_plot, aes(x = -lon, y = phi, color = over_land),
             size = 0.2, alpha = 0.7)
```

At the moment, there are three problems with this: (1) it takes a long time to run, (2) it might be missing sometimes, it looks like (saying over water when it's over land), although these cases do seem to be coastal, and (3) if it's over non-US land, this doesn't catch that.

Because of these concerns, I've got the code running right now to always specify that the storm center is over land. 

Note: 

- In a later version, it might make more sense to use a land mask rather than basing land / water on distance to the nearest county center.

### Calculate radius of maximum wind speed (Willoughby et al. 2006, Eqn 7a)

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_{max} = 46.4 e^{- 0.0155 V_{max} + 0.0169\phi}
$$

where: 

- $R_{max}$: Radius from the storm center to the point at which the maximum wind occurs (km)
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will7a
```

Notes: 

- This could be the place where we could most improve our models in later version. There are a lot of equations for calculating the radius of maximum windspeed, and there are also estimates based on radius data from the extended tracks database (and this is probably based more on observations for the real storm). We could potentially try out different equations for this part to optimize our model if we ever want to try that in the future.

### Willoughby et al. 2006, Eqn 10a

Next, we calculate $X_1$, which is a parameter that we need for the Willoughby model. Here is the equation from the Willoughby et al. 2006 paper:

$$
X_1 = 317.1 - 2.026V_{max} + 1.915 \phi
$$

where: 

- $X_1$: Parameter for Willoughby wind model
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10a
```

### Willoughby et al. 2006, Eqn 10b

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
n = 0.4067 + 0.0144 V_{max} - 0.0038 \phi
$$

where: 

- $n$: the exponential for the power law inside the eye
- $V_{max}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10b
```

### Willoughby et al. 2006, Eqn 10c

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
A = 0.0696 + 0.0049 V_{max} - 0.0064 \phi
$$
$$
A = \begin{cases}
0 & \text{ if } A < 0\\ 
 A & \text{ otherwise }
\end{cases}
$$

where: 

- $A$: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $V_{max}$: maximum wind (in m / s)
- $\phi$: absolute value of latitude (degrees)

```{r}
stormwindmodel::will10c
```

### Determine $R_1$ using numerical methods

Now, for the Willoughby model, we need to use a numerical method to determine the value of $R_1$ for the storm for a given observation point. To do that, we need to find the root of this equation: 

$$
w - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}} = 0
$$

where: 

- $w$: the weighting function (a function of $R_{max}$, $R_1$, and $R_2 - R_1$)
- $n$: the exponent for the power law inside the eye 
- $R_{max}$: radius at which the maximum wind occurs (km)
- $A$: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $X_1$: fitted slower exponential decay length in the outer vortex (km, I think)
- $X_2$: "the fixed rapid decay length" (Willoughby, p.1110) (km, I think). From Willoughby p.1110--1111: "We selected the most rapid decay length that seemed physically reasonable, 25 km."

The weighting function, $w$, is: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

$$
\xi = \frac{R_{max} - R_1}{R_2 - R_1}
$$

and where: 

- $w$: The weighting function
- $\xi$: A nondimensional argument
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

I wrote a function that uses the Newton-Raphson method, which seems similar to what was going on in the old code. You start with some initial guess, $x_0$, then calculate new values of $x_{n+1}$:

$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$

Until either the absolute value of $f(x_{n+1})$ is smaller than some $\epsilon$ threshold or you reach the maximum allowed number of iterations.

In this case, we're using it to try to find the value of $\xi$ that is a root for the following function: 

$$
f(\xi) = 126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}}
$$

The derivative of this function, which we need for the Newton-Raphson method, is:

$$
f'(\xi) = 5 * 126 \xi^4 - 6 * 420 \xi^5 + 7 * 540 \xi^6 - 8 * 315 \xi^7 + 9 * 70 \xi^8 
$$

```{r}
stormwindmodel::will3_right
stormwindmodel::will3_deriv_func
stormwindmodel::solve_for_xi
```

Notes: 

- It sounds like Newton-Raphson can be sensitive to the starting guess ($x_0$), so it's important to have a good starting guess. We may want to try to confirm that $x_0 = 0.5$ is a good starting guess for our application.
- I addd code to have have the function print a warning if the algorithm doesn't converge for that observation. It also sets $\xi$ to be missing (`NA`) if the algorithm doesn't converge. I don't have a great idea of how often we would expect it to not converge, so maybe this will clarify for us if this is a common problem as we work through historical hurricanes.

### Determine R1 once you've found xi

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_1 = R_{max} - \xi(R_2 - R_1)
$$

For this function, we're assuming that $R_2 - R_1$ (the width of the transition region) is 25 kilometers when $R_{max}$ is larger than 20 kilometers and 15 kilometers otherwise.

```{r}
stormwindmodel::calc_R1
```

Note: 

- From talking with John and Andrea, we want to make sure that the minimum radius estimated by the model is never lower than about 7.5 km because, if so, we could be estimating an $R_1$ that is zero or negative. If it ever gets this low, it would be during Charley or Ivan. For these, we might expect a max radius as low as 10 km (although the data estimates max radius based on wind speed, so it likely gives larger radii than were observed for small storms). 

### Determine R2 once you've found R1

Here is our equation for determining $R_2$ once we have $R_1$ and $R_{max}$:

$$
R_2 = \begin{cases}
R_1 + 25 & \text{ if } R_{max} > 20\\ 
R_1 + 15 & \text{ if } R_{max} \le 20
\end{cases}
$$

where: 

- $R_1$: Radius to the start of the transition region (km)
- $R_2$: Radius to the end of the transition region (km)

Questions:

- It seems the distance of the transition region is being set to 25 for larger storms (with $R_{max} > 20$) and to 15 for smaller storms (with $R_{max} \le 20$). I'm not sure if this is an arbitrary choice, or is there's some reference for this choice?

# Calculate wind speed at each grid point 

Next, we calculate wind characteristics at each grid point (or county center location) for every storm observation. These characteristics are: 

- `max_gust`: Maximum value of surface-level (10 meters) sustained winds, in meters per second, over the length of the storm at the given location
- `max_sust`: Maximum value of surface-level (10 meters) gust winds, in meters per second, over the length of the storm at the given location
- `gust_duration`: Length of time, in minutes, that surface-level sustained winds were above a certain wind speed cutoff (e.g., 20 meters per second)
- `sust_duration`: Length of time, in minutes, that surface-level gust winds were above a certain wind speed cutoff (e.g., 20 meters per second)

I've created the following function to calculate these characteristics at a location (note: this function calculates wind characteristics at a single location; I have a later function that applies this to all of our grid points):

```{r}
stormwindmodel::calc_grid_wind
```

Again, I've written this function so it uses a lot of smaller "helper" functions for each step. I have specific questions about some of those below. As an input, this function requires both the output dataframe from `add_wind_radii` (which gives all of the parameters for the Willoughby model at each point on the storm's track) and also a location (latitude and longitude) where you want to model winds. To work well with later functions, this location information should be input as a one-row dataframe rather than a vector. That `grid_point` input might look something like this:

```{r echo = FALSE}
data(county_points)
county_points[1, ]
```

(As a note, I've included in the package a dataset called `county_points` that has the population mean centers of each county in the states mapped in the later maps, so this dataset can be used directly from the package to determine county-level exposures.)

The column names for latitude and longitude must be `glat` and `glon`, both should be in decimal degrees, and the longitude should be expressed using negative numbers for the Western hemisphere (so, almost all of the points we'll have for Atlantic basin storms).

Here is an example of running that functions, and the output you get (notice that it only outputs a one-row matrix, because it only works with one location at a time):

```{r}
grid_point <- dplyr::filter(county_points, gridid == "37055")
calc_grid_wind(grid_point = grid_point,
               with_wind_radii = with_wind_radii)
```

(This example point is for Dare County, NC, during Hurricane Floyd.)

If you want, you can change the cutoffs you're using for the duration measurements: 

```{r}
calc_grid_wind(grid_point = grid_point,
               with_wind_radii = with_wind_radii,
               gust_duration_cut = 15, 
               sust_duration_cut = 15)
```

### Get the radius from the storm center to the grid point

The first step is to determine the distance between the grid point and the center of the storm ($r$). As with the previous main function, here I am using the haversine method of great circle distance to calculate this distance. For this, I use the `latlon_to_km` function given in the code shown above.

Notes: 

- Again, if this is taking a lot of computation time, we could probably use a simpler method without much loss of accuracy. 

### Determine tangential gradient wind speed at each location

Next, the package calculates $V(r)$, the tangential wind component at the grid point, which is at radius $r$ from the storm center. Note there are different equations for this for (1) the eye to the start of the transition region; (2) outside the transition region; and (3) within the transition region.

First, if $r \le R_1$, you are supposed to use this equation to calculate $V(r)$ (Willoughby et al. 2006, Eqn 1 (a)):

$$
V(r) = V_i = V_{max} \left( \frac{r}{R_{max}} \right)^n, (0 \le r \le R_1)
$$

Next, if $r \ge R_2$, you are suppose to use this equation to calculate $V(r)$ using this equation (Willoughby et al. 2006, Eqn 4; dual-exponential replacement of Eqn 1 (b)):

$$
V(r) = V_o = V_{max}\left[(1 - A) e^\frac{R_{max} - r}{X_1} + A e^\frac{R_{max} - r}{X_2}\right], R_2 < r
$$

Finally, if $r$ for the grid point is between $R_1$ and $R_2$, we need to calculate $\xi$ using the value we calculated for $r$ for the grid point: 

$$
\xi = \frac{r - R_1}{R_2 - R_1}
$$

and then: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

- $w$: Weighting variable
- $\xi$: A nondimensional argument
- $r$: radius from the storm center to the grid point (in km)
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

Willoughby et al. 2006, Eqn 1 (c):

$$
V(r) = V_i (1 - w) + V_o w, (R_1 \le r \le R_2)
$$

All of this is wrapped in the `will1` function (named after the equation in Willoughby et al.):

```{r}
stormwindmodel:::will1
```

### Calculate the direction of gradient winds at each location 

So far, the model has just calculated the the rotational component of the wind speed at each grid location (tangential wind). Now we need to add back in the forward motion component of the wind speed (translational wind) at each location. This requires, for each grid point, adding the separate vectors of tangential and translational winds. When these vectors point in the same direction, the total storm winds will be increased by the forward motion (the right side of the storm). Conversely, on the left side of the storm, the forward motion of the storm will offset some of the storm-related wind. 

We've already determined the direction of the forward direction of the storm. So, to add the two wind components together, we need to get the direction of the storm winds at each location we want to assess (grid points or counties).

First, we need to determine, for each storm location, the direction from the storm center to the locations. For this, we can use the `calc_bearing` function that we used earlier to determine the bearing of the storm at each storm observation. Now, we use it to calculate the angle from the storm center to the grid point:

```{r}
stormwindmodel:::calc_bearing
```

Next, we calculate the gradient wind direction based on the bearing of a location from the storm. This gradient wind direction is calculated by adding 90 degrees to the bearing of the grid point from the storm center.

### Go from gradient level to surface level winds

Now, to get estimated surface-level tangential winds from gradient-levels winds, we reverse what we did before, again using methods from Knaff et al., 2011. 

In this case, we can always assume we're over land, not water, so we always reduce the reduction factor by 20%. Now, however, we cannot assume that $r$ is always $R_{max}$, so we need to include a function that calculates the reduction factor as a function of radius from the storm center.

Here is the function we use for this part:

```{r}
stormwindmodel:::gradient_to_surface
```

This is from Figure 3 in Knaff et al. 2011. It uses a reduction factor of 0.90 up to a radius of 100 km, a reduction factor of 0.75 for any radius 700 km or greater, and a linear decreasing reduction factor for any radius between those two radius values. If the point is over land (true for any county), this reduction factor is further reduced by 20%.
 
```{r, fig.align = "center", fig.width = 4, fig.height = 2.5}
rf_example <- data.frame(r = 0:800,
                         rf = mapply(
                           stormwindmodel:::gradient_to_surface, 
                           track = 1, r = 0:800))
ggplot(rf_example, aes(x = r, y = rf)) + 
  geom_line() + 
  theme_minimal() + 
  xlab("Radius (km)") + 
  ylab("Reduction factor") + 
  ylim(c(0.5, 0.9))
```


### Calculate the surface wind direction

The next step is to change from the gradient wind direction to the surface wind direction. To do this, we need to add an inflow angle by adding a certain number of degrees to the gradient wind direction (and then making sure the final answer is between 0 and 360 degrees). This step is necessary because surface friction changes the wind direction a bit near the surface compared to higher.

We are calculating inflow angle as a function of the distance from the storm center to the location and the storm's $R_{max}$ at that observation point (Phadke et al., 2003):

$$
\beta = \begin{cases}
 & 10 + \left(1 + \frac{R}{R_{max}}\right) \text{ if } R < R_{max}\\ 
 & 20 + 25\left(\frac{R}{R_{max}} - 1 \right ) \text{ if } R_{max} \le R \le 1.2R_{max}\\ 
 & 25 \text{ if } R \ge 1.2R_{max}
\end{cases}
$$

Then, over land, the inflow angle should be about 20 degrees more than it is over water. Therefore, after calculating the inflow angle from the equation above, I am adding 20 degrees to the value since all of our locations are over land. The final calculation, then, is:

$$
swd = gwd + \beta + 20
$$

Here is the new function for this step:

```{r}
add_inflow
```

### Add back in wind component from forward speed of storm

Next, to add back in the storm's forward motion at each grid point, we reverse what we did before with the Phadke correction factor from Phadke et al., 2003, Eq. 12. We calculate a constant correction factor (`correction_factor`), as a function of `r`, radius from the storm center to the grid point, and `R_{max}`, radius from storm center to maximum winds. We then correct both the u- and v-components of forward speed with this correction factor, add these to the u- and v-components of tangential surface wind, and then use these u- and v-components to calculate the magnitude of total wind associated with the storm at the grid point:

```{r}
stormwindmodel:::add_forward_speed
```

### Calculate 3-second gust wind speed from sustained wind speed

The last step in the code calculates gust wind speed from sustained wind speed by applying a gust factor:

$$
\mbox{gust speed} = \mbox{gust factor}*\mbox{sustained wind speed}
$$

The old code used a gust factor of 1.3. However, it sounds like we should be using a higher gust factor since our locations are over land. In one of the sources I was looking at, there's this table for this gust factor: 
Location | Gust factor
---------|-------------
in-land | 1.49
just offshore | 1.36
just onshore | 1.23
at sea | 1.11

In the new code, I'm using the "in-land" value for the gust factor, which is a bit higher than the gust factor in the old code.

```{r eval = FALSE}
# New code
gust_windspd = windspd * 1.49
```

## Putting everything together

There's a wrapper function called `get_grid_winds` that puts everything together. As inputs, it takes the storm tracks and the grid point locations. It outputs a dataframe like this: 

```{r cache = TRUE}
grid_winds_katrina <- get_grid_winds(hurr_track = subset(hurr_tracks,
                                                  storm_id == "Katrina-2005"),
                                     grid_df = county_points)
```

Here is what the start of that dataset looks like: 

```{r}
head(grid_winds_katrina)
```

with the maxmium sustained and gust wind speeds (in meters per second) and duration of winds over 20 meters per second for each wind type (this cutoff point can be customized with the `gust_duration` and `sust_duration` arguments) added for each grid point.

I also have a function to map county-level estimates. Here's an example of calculating and mapping county winds for Katrina:

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
a <- map_wind(grid_winds_katrina, value = "max_gust") + 
  ggtitle("Maximum gust wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

a <- map_wind(grid_winds_katrina, value = "max_sust") + 
  ggtitle("Maximum sustained wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

# Show in knots
a <- map_wind(grid_winds_katrina, value = "max_gust",
              wind_metric = "knots") + 
  ggtitle("Maximum gust wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

a <- map_wind(grid_winds_katrina, value = "max_sust",
              wind_metric = "knots") + 
  ggtitle("Maximum sustained wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

# Sustained winds of 20 m / s or more
a <- map_wind(grid_winds_katrina, value = "max_sust", 
         break_point = 20)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

# Sustained winds of 34 knots or more
a <- map_wind(grid_winds_katrina, value = "max_sust", wind_metric = "knots", 
         break_point = 34)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

# Sustained winds of 50 knots or more
a <- map_wind(grid_winds_katrina, value = "max_sust", wind_metric = "knots", 
         break_point = 50)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)

# Sustained winds of 64 knots or more
a <- map_wind(grid_winds_katrina, value = "max_sust", wind_metric = "knots", 
         break_point = 64)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```


