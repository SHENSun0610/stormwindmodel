---
title: "Details of `stormwindmodel` package"
author: "G. Brooke Anderson, Andrea Schumacher, Seth Guikema, Joshua M. Ferreri, Steven Quiring"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo = FALSE, message = FALSE}
library(stormwindmodel)
library(hurricaneexposure)
library(hurricaneexposuredata)
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)
library(ggthemes)
```

## Overview of wind modeling process

Here is an overview of the wind modeling process implemented by this package: 

1. Impute location and maximum wind speed from hurricane track data (every 6 hours) to more frequent intervals. The default is to impute to every 15 minutes.
2. For each storm track location, calculate all the inputs needed for the Willoughby wind speed model (forward speed, direction of forward motion of the storm, gradient-level wind speed, radius of maximum winds, parameters for decay of winds away from the storm's center for Willoughby model). 
3. For each county center (or other grid point), estimate surface-level sustained wind and 3-second wind gusts at all storm observation points (i.e., all points along the interpolated storm track). This step includes: measuring distance to county from storm center (radius); calculating tangential gradient wind components at that grid point; calculating gradient wind direction at that grid point; calculating surface wind speed; calculating surface wind direction, adding storm forward motion back into surface wind estimate.
4. Determine for each county: the maximum sustained winds and wind gust speeds at any point on the storm's track; the duration of sustained and gust winds over a certain speed (i.e., how many minutes winds were above a cutoff).

This process is conducted in the `stormwindmodel` package using three main functions: `create_full_track`, `add_wind_radii`, and `calc_grid_wind`. Each of these functions has a number of helper functions to do each required modeling step. Details of all of these are included in this vignette. The full process is then wrapped in the `get_grid_winds` function, which is the main function most people will use from this package. 

## Variable definitions

Here are variables used in this modeling process. 

```{r echo = FALSE}
var_names <- dplyr::data_frame(var = c("`vmax`",
                                       "`vmax_sfc_sym`",
                                       "`vmax_gl`",
                                       "`tclat`",
                                       "`tclon`",
                                       "`tcspd`",
                                       "`tcspd_u`", 
                                       "`tcspd_v`",
                                       "`tcdir`",
                                       "`X1`",
                                       "`X2`",
                                       "`n`",
                                       "`A`",
                                       "`xi`",
                                       "`R1`",
                                       "`R2`",
                                       "`beta`",
                                       "`Vi`",
                                       "`V0`",
                                       "`wind_gl_aa`",
                                       "`wind_gl`",
                                       "`cdist`",
                                       "`chead`",
                                       "`wind_sfc_sym_u`",
                                       "`wind_sfc_sym_v`",
                                       "`wind_sfc_u`",
                                       "`wind_sfc_v`",
                                       "`r`",
                                       "`Rmax`",
                                       "`reduction_factor`",
                                       "`windspeed`",
                                       "`gustspeed`",
                                       "`vmax_sust`",
                                       "`vmax_gust`",
                                       "`sust_dur`",
                                       "`gust_dur`"),
                               math = c("$V_{max}$",
                                        "$V_{max,sym}$",
                                        "$V_{max,G}$",
                                        "$\\phi$",
                                        "$L$",
                                        "$V_F$",
                                        "$V_{F,u}$",
                                        "$V_{F,v}$",
                                        "$\\theta$",
                                        "$X_1$",
                                        "$X_2$",
                                        "$n$",
                                        "$A$",
                                        "$\\xi$",
                                        "$R_1$",
                                        "$R_2$",
                                        "$\\beta$",
                                        "$V_i$",
                                        "$V_0$",
                                        "$V_G(r)$",
                                        "?",
                                        "$C_{dist}$",
                                        "$C_{head}$",
                                        "$V_{sfc,sym,u}$",
                                        "$V_{sfc,sym,v}$",
                                        "$V_{sfc,u}$",
                                        "$V_{sfc,v}$",
                                        "$r$",
                                        "$R_{max}$",
                                        "$f_r$",
                                        "$V_{sfc}$",
                                        "$V_{sfc,gust}$",
                                        "$V_{max,sust}$",
                                        "$V_{max,gust}$",
                                        "$T_{sust}$",
                                        "$T_{gust}$"),
                               defn = c("Max 10-m 1-min sustained wind",
                                        "Max 10-m 1-min sustained wind with motion asymmetry removed",
                                        "Max gradient-level 1-min sustained wind",
                                        "Tropical cyclone center position latitude",
                                        "Tropical cyclone center position longitude (0 to 360)",
                                        "Tropical cyclone forward speed",
                                        "Tropical cyclone forward speed, u-component",
                                        "Tropical cyclone forward speed, v-component",
                                        "Tropical cyclone forward direction",
                                        "Parameter for Willoughby model",
                                        "Parameter for Willoughby model",
                                        "Parameter for Willoughby model",
                                        "Parameter for Willoughby model",
                                        "Parameter for Willoughby model",
                                        "Lower boundary of the transition zone for Willoughby model",
                                        "Upper boundary of the transition zone for Willoughby model",
                                        "Inflow angle (0 to 360)",
                                        "Azimuthal average winds inside $R_1$",
                                        "Azimuthal average winds outside $R_2$",
                                        "Azimuthal average winds, varies by radius $r$", 
                                        "Gradient level winds (u, v) at grid point",
                                        "Distance from tropical cyclone to grid point",
                                        "Heading of grid point from tropical cyclone center",
                                        "Symmetric surface winds at grid point, u-component",
                                        "Symmetric surface winds at grid point, v-component",
                                        "Asymmetric surface winds at grid point, u-component",
                                        "Asymmetric surface winds at grid point, v-component",
                                        "Radius from the center of tropical cyclone",
                                        "Radius of maximum winds",
                                        "Reduction factor for converting between surface and gradient winds",
                                        "Asymmetric surface sustained wind at grid point",
                                        "Asymmetric surface wind gust at grid point",
                                        "Max 10-m 1-min sustained wind experienced at grid point",
                                        "Max 10-m 1-min gust wind experienced at grid point",
                                        "Duration of time a certain sustained wind was experienced at grid point",
                                        "Duration of time a certain gust wind was experienced at grid point"),
                               units = c("m/s",
                                         "m/s",
                                         "m/s",
                                         "degrees North",
                                         "degrees East",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "degrees (trigonomical)",
                                        "--",
                                        "--",
                                        "--",
                                        "--",
                                        "--",
                                        "km",
                                        "km",
                                         "degrees",
                                         "m/s",
                                         "m/s",
                                         "km",
                                         "degrees (trigonomical)",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "km",
                                         "km",
                                         "--",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "m/s",
                                         "minutes",
                                         "minutes"))
knitr::kable(var_names, col.names = c("R variable", "Expression in equations",
                                      "Definition", "Units"))
```

## Impute storm tracks

The tropical cyclone best tracks have observations every six hours (plus, for some, an observation at landfall). Our package has a function called `create_full_track` that imputes both locations (latitude and longitude) and intensity (maximum wind speed) from the hurricane tracks data to a finer time resolution (default is 15 minutes, but you can also select other values using the `tint` argument). This imputation uses a natural cubic spline, with the degrees of freedom set as the number of timed observations for the storm in the input data (typically best tracks data) divided by two. The option `tint` in this function gives the time interval you want to use, in hours (e.g., 0.25 for 15 minutes). 

```{r}
stormwindmodel::create_full_track
```

Here is an example of running this function like this, where `floyd_tracks` is a dataframe with the hurricane track information for Hurricane Floyd (saved as data with this package), and `tint` is the desired time interval to which to impute: 

```{r}
data("floyd_tracks")
full_track <- create_full_track(hurr_track = floyd_tracks, tint = 0.25)
full_track %>% slice(1:3)
```

## Add Willoughby inputs and parameters

The next step is to process this imputed track and add, for each observation point, the inputs and model parameters required for the Willoughby model. This process is done using the `add_wind_radii` function. As an input, it takes the imputed dataframe create by the `create_full_track` function. It outputs the same dataframe, but with columns added for the inputs and parameters required for the Willoughby wind model. 

For the Hurricane Floyd example, here is an example of running the code and the first three and last three line of output: 

```{r}
with_wind_radii <- stormwindmodel::add_wind_radii(full_track = full_track)
with_wind_radii %>% slice(c(1:3, (n()-3):n()))
```

This adds lots of measurements and parameters for each observation. The last line has some missing values. This is because you need points after the current point to calculate forward speed and bearing of the storm. 

Here is the full code for this function:

```{r}
stormwindmodel::add_wind_radii
```

You can see that this function is mostly wrapping helper functions, which do each step of the process. I describe these helpers (and questions I have about them) below. 

Note: 

- Because I've made this modular, it would be pretty easy to re-code any of the helper functions in C++ to increase speed. However, other than the function that uses the Newton-Raphson method, I would imagine that this step is not nearly as slow as the step that calculates wind speed at each grid point, so this might be lower priority for shifting to C++. I have an undergrad who is looking into which helper functions throughout the package we might want to write in C++ to improve performance. 

### Calculate the storm's forward speed

The first step is to determine the speed that the storm is moving forward (translational speed), in meters per second. We want to remove this from the observed maximum wind speed to get an estimate of the maximum wind speed associated just with the rotational movement of the storm, which is what needs to go into the Willoughby model. This asymmetry needs to be removed before we convert winds to gradient level. We will add back in a forward motion component to the surface winds at grid points near the end of the the modeling process.

In the new code, I'm using the Haversine method with great circle distance to calculate the distance, in kilometers, between the storm's latitude and longitude coordinates for the current observation and the following observation. I then get the time difference between those two points. From these, I estimate the storm's forward (translational) velocity. I convert to get this speed to meters per second (from kilometers per hour), so it's in the same units as $V_{max}$ from the imputed storm tracks.

Here is the equation I use for the Haversine method with great circle distance to calculate the distance (in kilometers) between the two locations based on their latitudes and longitudes. 

$$
hav(\gamma) = hav(\phi_1 - \phi_2) + cos(\phi_1)*cos(\phi_2)*hav(L_1 - L_2)
$$
$$
D = R_{earth} * \gamma 
$$

where:

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $\gamma$: Intermediary result
- $hav(\gamma)$: The haversine function, $hav(\gamma) = sin^2 \left(\frac{\gamma}{2}\right)$
- $R_{earth}$: Radius of the earth, here assumed to be 6378.14 kilometers
- $D$: Distance between the two locations, in kilometers

In the package, first we've got a helper function to convert between degrees and radians (`degrees_to_radians`), and then a function called `latlon_to_km` that uses the haversine approach to calculate the distance between two storm center locations (`tclat_1` and `tclat_2` are the two storm center latitudes; `tclon_1` and `tclon_2` are the two storm center longitudes):

```{r}
stormwindmodel:::degrees_to_radians
stormwindmodel:::latlon_to_km
```

We then have a function called `calc_forward_speed` that caculates the distance between two latitude-longitude pairs, calculates the time difference in their time stamps, and from that determines the forward speed in kilometers per hour and converts it to meters per second. 

```{r}
stormwindmodel:::calc_forward_speed
```

### Calculate direction of storm movement

Next, we need to calculate the direction of the motion of the storm (storm bearing). Later, we'll use this to add back in a component for the forward motion of the storm into the wind estimates. 

I found an equation for calculating the bearing of one point from another point based on latitude and longitude. So, this is calculating the bearing of a later storm observation, as seen from an earlier storm observation. The function also restricts the output to be between 0 and 360 degrees using modular arithmetic (`%% 360`). 

$$
S = cos(\phi_{2,rad}) * sin(L_{1,rad} - L_{2,rad})
$$

$$
C = cos(\phi_{1,rad}) * sin(\phi_{2,rad}) - sin(\phi_{1,rad}) * cos(\phi_{2,rad}) * cos(L_{1,rad} - L_{2,rad})
$$

$$
\theta = atan2(S, C) * \frac{180}{\pi} + 90
$$

where: 

- $\phi_{1,rad}$: Latitude of first location, in radians
- $L_{1,rad}$: Longitude of first location, in radians
- $\phi_{2,rad}$: Latitude of second location, in radians
- $L_{2,rad}$: Longitude of second location, in radians
- $S$, $C$: Intermediary results
- $\theta$ is the direction of the storm movement, in degrees

This is implemented in our package through the `calc_bearing` function:

```{r}
stormwindmodel::calc_bearing
```

### Calculate u- and v-components of forward speed

Next, we use the estimated magnitude and direction of the storm's forward speed to calculate u- and v-components of this forward speed. Later, we will add back in these two components to the modeled surface wind speed at grid points, after adjusting for the Phadke correction factor for forward motion.

To calculate the u- and v-components of forward motion, $V_{F,u}$ and $V_{F,v}$, we used: 

$$
V_{F,u} = \left|\overrightarrow{V_{F}}\right| cos(\theta)
$$

$$
V_{F,v} = \left|\overrightarrow{V_{F}}\right| sin(\theta)
$$

where $\theta$ is the direction of the storm movement (0 for due east, 90 for due north, etc.).

### Adjust wind speed to remove forward motion of storm

Next, there's a function called `remove_forward_speed` that uses the estimated forward speed in equation 12 (and accompanying text) from Phadke et al. 2003 to adjust wind speed to remove the component from forward motion. 

Because here we are trying to adjust the maximum sustained wind to remove the component from forward speed, we can assume that we are adjusting wind speed at the radius of maximum winds and for winds blowing in the same direction as the direction of the forward motion of the storm. Therefore, the correction term for forward motion is $U = 0.5 * V_F$ (Phadke et al. 2003), or half the total forward speed of the storm. We substract this correction factor from the maximum sustained wind speed to remove the forward component, and because we assume that the maximum winds are blowing in the same direction as the direction of the storm's forward motion, we can directly subtract this correction term from the magnitude of the wind speed (rather than needing to break into u- and v-components for a vector addition).

If $V_{max}$ after removing the forward storm motion is ever negative, the `remove_forward_speed` function resets the value to 0 m / s.

```{r}
stormwindmodel:::remove_forward_speed
```

### Convert 1-min sustained wind at 10 m to gradient level wind speed 

The extended tracks database gives maximum winds as one minute sustained wind speeds 10 meters above the ground. To make calculations easier (by not having to deal with friction), we convert the 1-minute sustained wind speeds at 10 meters (`vmax` in the created dataframe), which is what is given in the hurricane tracking data, to gradient level wind speed (`vmax_gl` in the created dataframe), using the following equation:

$$
V_{max,G} = \frac{V_{max,sym}}{f_r}
$$

where:

- $V_{max,G}$: Mean wind speed at gradient level (m / s) 
- $V_{max,sustained}$: Surface wind speed (10 meters above the water or ground) (m / s)
- $f_r$: Reduction factor for $r \le$ 100 km. At this point, we're calculating things for $r = R_{max}$.

The reduction factor come from Knaff et al., 2003, Figure 3. We assume that $R_{max}$ is always 100 km or less. Then, $f_r$ is 0.9 if the storm's center is over water and 80% of that, 0.72, if the storm's center is over land.  

```{r}
stormwindmodel::calc_gradient_speed
```

To determine if the storm center is over land or over water, we have included a dataset with the package called "landmask". This dataset gives locations of a grid of points in eastern US and a factor saying whether each point is over land or water:  

```{r}
data(landmask)
head(landmask)
```

We wrote a function called `check_over_land` to find the closest grid point for a storm location and determine whether the storm is over land or over water. 

```{r}
stormwindmodel:::check_over_land
```

Here is an example of applying this function to the tracks for Hurricane Floyd:

```{r fig.width = 8, fig.height = 5}
floyd_tracks$land <- mapply(stormwindmodel:::check_over_land,
                            tclat = floyd_tracks$latitude,
                            tclon = -floyd_tracks$longitude)
ggplot(landmask, aes(x = longitude - 360, y = latitude, color = land)) +
  geom_point() + 
  geom_point(data = floyd_tracks, aes(x = longitude, y = latitude, 
                                     color = NULL, shape = land)) + 
  scale_color_discrete("Land mask") + 
  scale_shape_discrete("Track over land")
```

In the `add_wind_radii` function, there is code to check whether the point is overland and then apply the proper reduction factor based on whether the point is over land or water:

```{r eval = FALSE}
over_land = mapply(check_over_land, tclat, tclon),
vmax_gl = mapply(calc_gradient_speed,
                vmax_sfc_sym = vmax_sfc_sym,
                over_land = over_land)
```

### Calculate radius of maximum wind speed (Willoughby et al. 2006, Eqn 7a)

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_{max} = 46.4 e^{- 0.0155 V_{max,G} + 0.0169\phi}
$$

where: 

- $R_{max}$: Radius from the storm center to the point at which the maximum wind occurs (km)
- $V_{max,G}$: the tangential wind component of the gradient-level maximum wind speed (m / s)
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will7a
```

### Willoughby et al. 2006, Eqn 10a

Next, we calculate $X_1$, which is a parameter that we need for the Willoughby model. Here is the equation from the Willoughby et al. 2006 paper:

$$
X_1 = 317.1 - 2.026V_{max,G} + 1.915 \phi
$$

where: 

- $X_1$: Parameter for Willoughby wind model
- $V_{max,G}$: Maximum gradient-level 1-min sustained wind
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10a
```

### Willoughby et al. 2006, Eqn 10b

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
n = 0.4067 + 0.0144 V_{max,G} - 0.0038 \phi
$$

where: 

- $n$: the exponential for the power law inside the eye
- $V_{max,G}$: Maximum gradient-level 1-min sustained wind
- $\phi$: Latitude, in decimal degrees

```{r}
stormwindmodel::will10b
```

### Willoughby et al. 2006, Eqn 10c

Next, we need to calculate another Willoughby parameter. Here is the equation from the Willoughby et al. 2006 paper:

$$
A = 0.0696 + 0.0049 V_{max,G} - 0.0064 \phi
$$
$$
A = \begin{cases}
0 & \text{ if } A < 0\\ 
 A & \text{ otherwise }
\end{cases}
$$

where: 

- $A$: A parameter for the Willoughby model: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $V_{max,G}$: Maximum gradient-level 1-min sustained wind
- $\phi$: absolute value of latitude (degrees)

```{r}
stormwindmodel::will10c
```

### Determine $R_1$ using numerical methods

Now, for the Willoughby model, we need to use a numerical method to determine the value of $R_1$ for the storm for a given observation point. To do that, we need to find the root of this equation: 

$$
w - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}} = 0
$$

where: 

- $w$: the weighting function (a function of $R_{max}$, $R_1$, and $R_2 - R_1$)
- $n$: A parameter for the Willoughby model: the exponent for the power law inside the eye 
- $R_{max}$: radius at which the maximum wind occurs (km)
- $A$: "the fitted contribution of the faster exponential to the profile" (Willoughby, p.110)
- $X_1$: A parameter for the Willoughby model: fitted slower exponential decay length in the outer vortex (km, I think)
- $X_2$: A parameter for the Willoughby model: "the fixed rapid decay length" (Willoughby, p.1110) (km, I think). From Willoughby p.1110--1111: "We selected the most rapid decay length that seemed physically reasonable, 25 km."

The weighting function, $w$, is: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

$$
\xi = \frac{R_{max} - R_1}{R_2 - R_1}
$$

and where: 

- $w$: The weighting function
- $\xi$: A nondimensional argument
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

I wrote a function that uses the Newton-Raphson method, which seems similar to what was going on in the old code. You start with some initial guess, $x_0$, then calculate new values of $x_{n+1}$:

$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$

Until either the absolute value of $f(x_{n+1})$ is smaller than some $\epsilon$ threshold or you reach the maximum allowed number of iterations.

In this case, we're using it to try to find the value of $\xi$ that is a root for the following function: 

$$
f(\xi) = 126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 - \frac{n ((1 - A) X_1 + 25 A)}{n ((1 - A) X_1 + 25 A) + R_{max}}
$$

The derivative of this function, which we need for the Newton-Raphson method, is:

$$
f'(\xi) = 5 * 126 \xi^4 - 6 * 420 \xi^5 + 7 * 540 \xi^6 - 8 * 315 \xi^7 + 9 * 70 \xi^8 
$$

```{r}
stormwindmodel::will3_right
stormwindmodel::will3_deriv_func
stormwindmodel::solve_for_xi
```

Notes: 

- It sounds like Newton-Raphson can be sensitive to the starting guess ($x_0$), so it's important to have a good starting guess. We may want to try to confirm that $x_0 = 0.5$ is a good starting guess for our application.
- I added code to have have the function print a warning if the algorithm doesn't converge for that observation. It also sets $\xi$ to be missing (`NA`) if the algorithm doesn't converge. I don't have a great idea of how often we would expect it to not converge, so maybe this will clarify for us if this is a common problem as we work through historical hurricanes.
- It would be worth checking if R already has a function for doing Newton-Raphson that's been optimized to run faster.

### Determine R1 once you've found xi

Here is the equation from the Willoughby et al. 2006 paper:

$$
R_1 = R_{max} - \xi(R_2 - R_1)
$$

For this function, we're assuming that $R_2 - R_1$ (the width of the transition region) is 25 kilometers when $R_{max}$ is larger than 20 kilometers and 15 kilometers otherwise.

```{r}
stormwindmodel::calc_R1
```

Note: 

- We want to make sure that the smallest $R_{max}$ estimated by the model is never lower than about 7.5 km because, if so, we could be estimating an $R_1$ that is zero or negative. If it ever gets this low, it would be during Charley or Ivan. For these, we might expect a max radius as low as 10 km (although the data estimates max radius based on wind speed, so it likely gives larger radii than were observed for small storms). 

### Determine R2 once you've found R1

Here is our equation for determining $R_2$ once we have $R_1$ and $R_{max}$:

$$
R_2 = \begin{cases}
R_1 + 25 & \text{ if } R_{max} > 20\\ 
R_1 + 15 & \text{ if } R_{max} \le 20
\end{cases}
$$

where: 

- $R_1$: Radius to the start of the transition region (km)
- $R_2$: Radius to the end of the transition region (km)

Questions:

- It seems the distance of the transition region is being set to 25 km for larger storms (with $R_{max} > 20$) and to 15 km for smaller storms (with $R_{max} \le 20$). I'm not sure if this is an arbitrary choice, or is there's some reference for this choice?

## Calculate wind speed at each grid point 

Next, we calculate wind characteristics at each grid point (or county center location) for every storm observation. These characteristics are: 

- `max_gust`: Maximum value of surface-level (10 meters) sustained winds, in meters per second, over the length of the storm at the given location
- `max_sust`: Maximum value of surface-level (10 meters) gust winds, in meters per second, over the length of the storm at the given location
- `gust_duration`: Length of time, in minutes, that surface-level sustained winds were above a certain wind speed cutoff (e.g., 20 meters per second)
- `sust_duration`: Length of time, in minutes, that surface-level gust winds were above a certain wind speed cutoff (e.g., 20 meters per second)

I've created the following function to calculate these characteristics at a location (note: this function calculates wind characteristics at a single location; I have a later function that applies this to all of our grid points):

```{r}
stormwindmodel::calc_grid_wind
```

Again, I've written this function so it uses a lot of helper functions for each step. I have specific questions about some of those below. As an input, this function requires both the output dataframe from `add_wind_radii` (which gives all of the parameters for the Willoughby model at each point on the storm's track) and also a location (latitude and longitude) where you want to model winds. To work well with later functions, this location information should be input as a one-row dataframe rather than a vector. That `grid_point` input might look something like this:

```{r echo = FALSE}
data(county_points)
county_points[1, ]
```

(As a note, I've included in the package a dataset called `county_points` that has the population mean centers of each county in the states mapped in the later maps, so this dataset can be used directly from the package to determine county-level exposures.)

The column names for latitude and longitude must be `glat` and `glon`, both should be in decimal degrees, and the longitude should be expressed using negative numbers for the Western hemisphere (so, almost all of the points we'll have for Atlantic basin storms).

Here is an example of running that functions, and the output you get (notice that it only outputs a one-row matrix, because it only works with one location at a time):

```{r}
grid_point <- county_points %>% filter(gridid == "37055")
calc_grid_wind(grid_point = grid_point,
               with_wind_radii = with_wind_radii)
```

(This example point is for Dare County, NC, during Hurricane Floyd.)

If you want, you can change the cutoffs you're using for the duration measurements: 

```{r}
calc_grid_wind(grid_point = grid_point,
               with_wind_radii = with_wind_radii,
               gust_duration_cut = 15, 
               sust_duration_cut = 15)
```

### Get the radius from the storm center to the grid point

The first step is to determine the distance between the grid point and the center of the storm ($r$). As with the previous main function, here I am using the haversine method of great circle distance to calculate this distance. For this, I use the `latlon_to_km` function given in the code shown above.

### Determine tangential gradient wind speed at each location

Next, the package calculates $V_G(r)$, the gradient level 1-minute sustained wind at the grid point, which is at radius $r$ from the tropical cyclone center. Note there are different equations for this for (1) the eye to the start of the transition region; (2) outside the transition region; and (3) within the transition region.

First, if $r \le R_1$, you are supposed to use this equation to calculate $V_G(r)$ (Willoughby et al. 2006, Eqn 1 (a)):

$$
V_G(r) = V_i = V_{max,G} \left( \frac{r}{R_{max}} \right)^n, (0 \le r \le R_1)
$$

Next, if $r \ge R_2$, you are suppose to use this equation to calculate $V(r)$ using this equation (Willoughby et al. 2006, Eqn 4; dual-exponential replacement of Eqn 1 (b)):

$$
V_G(r) = V_o = V_{max,G}\left[(1 - A) e^\frac{R_{max} - r}{X_1} + A e^\frac{R_{max} - r}{X_2}\right], R_2 < r
$$

Finally, if $r$ for the grid point is between $R_1$ and $R_2$, we need to calculate $\xi$ using the value we calculated for $r$ for the grid point: 

$$
\xi = \frac{r - R_1}{R_2 - R_1}
$$

and then: 

$$
w = \begin{cases}
0 & \text{if } \xi < 0 \\ 
126 \xi^5 - 420 \xi^6 + 540 \xi^7- 315 \xi^8 + 70 \xi^9 & \text{if } 0 \le \xi \le 1\\
 1 & \text{if } \xi > 0
\end{cases}
$$

where: 

- $w$: Weighting variable
- $\xi$: A nondimensional argument
- $r$: radius from the storm center to the grid point (in km)
- $R_{max}$: radius at which the maximum wind occurs (km)
- $R_1$: lower boundary of the transition zone (in km from the storm center)
- $R_2$: upper boundary of the transition zone (in km from the storm center)

Willoughby et al. 2006, Eqn 1 (c):

$$
V_G(r) = V_i (1 - w) + V_o w, (R_1 \le r \le R_2)
$$

All of this is wrapped in the `will1` function (named after the equation in Willoughby et al.):

```{r}
stormwindmodel:::will1
```

### Calculate the direction of gradient winds at each location 

So far, the model has just calculated the the rotational component of the wind speed at each grid location (tangential wind). Now we need to add back in the forward motion component of the wind speed (translational wind) at each location. This requires, for each grid point, adding the separate vectors of tangential and translational winds. When these vectors point in the same direction, the total storm winds will be increased by the forward motion (the right side of the storm). Conversely, on the left side of the storm, the forward motion of the storm will offset some of the storm-related wind. 

We've already determined the direction of the forward direction of the storm. So, to add the two wind components together, we need to get the direction of the storm winds at each location we want to assess (grid points or counties).

First, we need to determine, for each storm location, the direction from the storm center to the locations. For this, we can use the `calc_bearing` function that we used earlier to determine the bearing of the storm at each storm observation. Now, we use it to calculate the angle from the storm center to the grid point:

```{r}
stormwindmodel:::calc_bearing
```

Next, we calculate the gradient wind direction based on the bearing of a location from the storm. This gradient wind direction is calculated by adding 90 degrees to the bearing of the grid point from the storm center.

### Go from gradient level to surface level winds

Now, to get estimated surface-level tangential winds from gradient-levels winds, we reverse what we did before, again using methods from Knaff et al., 2011. 

In this case, we can always assume we're over land, not water, so we always reduce the reduction factor by 20%. Now, however, we cannot assume that $r$ is always $R_{max}$, so we need to include a function that calculates the reduction factor as a function of radius from the storm center.

Here is the function we use for this part:

```{r}
stormwindmodel:::gradient_to_surface
```

This is from Figure 3 in Knaff et al. 2011. It uses a reduction factor of 0.90 up to a radius of 100 km, a reduction factor of 0.75 for any radius 700 km or greater, and a linear decreasing reduction factor for any radius between those two radius values. If the point is over land (true for any county), this reduction factor is further reduced by 20%.
 
```{r, fig.align = "center", fig.width = 4, fig.height = 2.5}
rf_example <- data.frame(r = 0:800,
                         rf = mapply(
                           stormwindmodel:::gradient_to_surface, 
                           wind_gl_aa = 1, cdist = 0:800))
ggplot(rf_example, aes(x = r, y = rf)) + 
  geom_line() + 
  theme_minimal() + 
  xlab("Radius (km)") + 
  ylab("Reduction factor") + 
  ylim(c(0.5, 0.9))
```


### Calculate the surface wind direction

The next step is to change from the gradient wind direction to the surface wind direction. To do this, we need to add an inflow angle by adding a certain number of degrees to the gradient wind direction (and then making sure the final answer is between 0 and 360 degrees). This step is necessary because surface friction changes the wind direction a bit near the surface compared to higher.

We are calculating inflow angle as a function of the distance from the storm center to the location and the storm's $R_{max}$ at that observation point (Phadke et al., 2003):

$$
\beta = \begin{cases}
 & 10 + \left(1 + \frac{R}{R_{max}}\right) \text{ if } R < R_{max}\\ 
 & 20 + 25\left(\frac{R}{R_{max}} - 1 \right ) \text{ if } R_{max} \le R \le 1.2R_{max}\\ 
 & 25 \text{ if } R \ge 1.2R_{max}
\end{cases}
$$

Then, over land, the inflow angle should be about 20 degrees more than it is over water. Therefore, after calculating the inflow angle from the equation above, I am adding 20 degrees to the value since all of our locations are over land. The final calculation, then, is:

$$
swd = gwd + \beta + 20
$$

Here is the new function for this step:

```{r}
add_inflow
```

### Add back in wind component from forward speed of storm

Next, to add back in the storm's forward motion at each grid point, we reverse what we did before with the Phadke correction factor from Phadke et al., 2003, Eq. 12. We calculate a constant correction factor (`correction_factor`), as a function of `r`, radius from the storm center to the grid point, and `R_{max}`, radius from storm center to maximum winds. We then correct both the u- and v-components of forward speed with this correction factor, add these to the u- and v-components of tangential surface wind, and then use these u- and v-components to calculate the magnitude of total wind associated with the storm at the grid point:

```{r}
stormwindmodel:::add_forward_speed
```

### Calculate 3-second gust wind speed from sustained wind speed

The last step in the code calculates gust wind speed from sustained wind speed by applying a gust factor:

$$
V_{sfc,gust} = f_g*V_{sfc}
$$

where $V_{sfc}$ is the asymmetric surface wind speed, V_{sfc,gust} is the surface gust wind speed, and $f_g$ is the gust factor.

The old code used a gust factor of 1.3. However, it sounds like we should be using a higher gust factor since our locations are over land. In one of the sources I was looking at, there's this table for this gust factor: 

Location | Gust factor
---------|-------------
in-land | 1.49
just offshore | 1.36
just onshore | 1.23
at sea | 1.11

In the new code, I'm using the "in-land" value for the gust factor, which is a bit higher than the gust factor in the old code.

```{r eval = FALSE}
# New code
gustspeed = windspeed * 1.49
```

## Putting everything together

There's a wrapper function called `get_grid_winds` that puts everything together. As inputs, it takes the storm tracks and the grid point locations. It outputs a dataframe like this: 

```{r cache = TRUE}
data("hurr_tracks", package = "hurricaneexposuredata")
grid_winds_katrina <- get_grid_winds(hurr_track = subset(hurr_tracks,
                                                  storm_id == "Katrina-2005"),
                                     grid_df = county_points)
```

Here is what the start of that dataset looks like: 

```{r}
head(grid_winds_katrina)
```

with the maxmium sustained and gust wind speeds (in meters per second) and duration of winds over 20 meters per second for each wind type (this cutoff point can be customized with the `gust_duration` and `sust_duration` arguments) added for each grid point.

I also have a function to map county-level estimates. Here's an example of calculating and mapping county winds for Katrina:

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
a <- map_wind(grid_winds_katrina, value = "vmax_gust") + 
  ggtitle("Maximum gust wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
a <- map_wind(grid_winds_katrina, value = "vmax_sust") + 
  ggtitle("Maximum sustained wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
# Show in knots
a <- map_wind(grid_winds_katrina, value = "vmax_gust",
              wind_metric = "knots") + 
  ggtitle("Maximum gust wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
a <- map_wind(grid_winds_katrina, value = "vmax_sust",
              wind_metric = "knots") + 
  ggtitle("Maximum sustained wind speeds")
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
# Sustained winds of 20 m / s or more
a <- map_wind(grid_winds_katrina, value = "vmax_sust", 
         break_point = 20)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
# Sustained winds of 34 knots or more
a <- map_wind(grid_winds_katrina, value = "vmax_sust", wind_metric = "knots", 
         break_point = 34)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
# Sustained winds of 50 knots or more
a <- map_wind(grid_winds_katrina, value = "vmax_sust", wind_metric = "knots", 
         break_point = 50)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```

```{r fig.width = 7, fig.height = 4, warning = FALSE, message = FALSE}
# Sustained winds of 64 knots or more
a <- map_wind(grid_winds_katrina, value = "vmax_sust", wind_metric = "knots", 
         break_point = 64)
hurricaneexposure::map_tracks("Katrina-2005", plot_object = a)
```


